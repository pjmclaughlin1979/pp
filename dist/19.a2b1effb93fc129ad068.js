(function(){(this||window).webpackJsonp.registerAbsMids({"esri/core/HandleOwner":1503,"esri/views/layers/LayerView":1504,"esri/core/pbf":1520,"esri/views/vectorTiles/renderers/rendererUtils":1608,"esri/views/vectorTiles/MemoryBuffer":1648,"esri/views/vectorTiles/Rect":1689,"esri/views/vectorTiles/TileHandler":1782,"esri/views/vectorTiles/RectangleBinPack":1783,"esri/views/vectorTiles/renderers/Renderer":1784,"esri/views/vectorTiles/GlyphMosaic":2183,"esri/views/vectorTiles/GlyphSource":2184,"esri/views/vectorTiles/SpriteMosaic":2185,"esri/views/2d/engine/webgl/BitBlitRenderer":2187,"esri/views/2d/engine/webgl/shaders/BitBlitPrograms":2188,"esri/views/2d/engine/webgl/shaders/sources/resolver":2189,"esri/views/2d/engine/webgl/shaders/sources/shaderRepository":2190,"esri/views/vectorTiles/renderers/BackgroundRenderer":2191,"esri/views/vectorTiles/renderers/CircleRenderer":2192,"esri/views/vectorTiles/renderers/FadeRecorder":2193,"esri/views/vectorTiles/renderers/FillRenderer":2194,"esri/views/vectorTiles/renderers/LineRenderer":2195,"esri/views/vectorTiles/renderers/SymbolRenderer":2196,"esri/views/vectorTiles/renderers/IconRenderer":2197,"esri/views/vectorTiles/renderers/SDFRenderer":2198,"esri/views/vectorTiles/renderers/TileInfoRenderer":2199,"esri/views/vectorTiles/renderers/shaders/ProgramCache":2200,"esri/views/vectorTiles/renderers/shaders/Programs":2201,"esri/views/vectorTiles/renderers/shaders/sources/resolver":2202,"esri/views/vectorTiles/renderers/shaders/sources/shaderRepository":2203})})(),(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{1503:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(2),i(1),i(6),i(17),i(0)],void 0===(r=function(e,t,i,n,r,o,a){return function(e){function t(){for(var t=[],i=0;i<arguments.length;i++)t[i]=arguments[i];var n=e.call(this)||this;return n.handles=new o,n}return i(t,e),t.prototype.destroy=function(){this.handles.destroy()},n([a.property({readOnly:!0})],t.prototype,"handles",void 0),n([a.subclass("esri.core.HandleOwner")],t)}(a.declared(r))}.apply(null,n))||(e.exports=r)},1504:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(2),i(1),i(48),i(1503),i(210),i(10),i(209),i(9),i(0)],void 0===(r=function(e,t,i,n,r,o,a,s,l,d,u){return function(e){function t(t){var i=e.call(this)||this;return i.layer=null,i.parent=null,i.view=null,i}return i(t,e),t.prototype.initialize=function(){var e=this;this.addResolvingPromise(this.layer),this.when().catch(function(t){if("layerview:create-error"!==t.name){var i=e.layer&&e.layer.id||"no id",n=e.layer&&e.layer.title||"no title";return s.getLogger(e.declaredClass).error("#resolve()","Failed to resolve layer view (layer title: '"+n+"', id: '"+i+"')",t),d.reject(t)}})},t.prototype.destroy=function(){this.layer=this.view=this.parent=null},Object.defineProperty(t.prototype,"suspended",{get:function(){return!this.canResume()},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"updating",{get:function(){return!this.suspended&&this.isUpdating()},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"visible",{get:function(){return!0===this.get("layer.visible")},set:function(e){void 0!==e?this._override("visible",e):this._clearOverride("visible")},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"fullOpacity",{get:function(){var e=function(e){return null==e?1:e};return e(this.get("layer.opacity"))*e(this.get("parent.fullOpacity"))},enumerable:!0,configurable:!0}),t.prototype.canResume=function(){return!this.get("parent.suspended")&&this.get("view.ready")&&this.get("layer.loaded")&&this.visible||!1},t.prototype.isUpdating=function(){return!1},n([u.property()],t.prototype,"layer",void 0),n([u.property()],t.prototype,"parent",void 0),n([u.property({readOnly:!0,dependsOn:["view","visible","layer.loaded","parent.suspended"]})],t.prototype,"suspended",null),n([u.property({type:Boolean,dependsOn:["suspended"],readOnly:!0})],t.prototype,"updating",null),n([u.property()],t.prototype,"view",void 0),n([u.property({dependsOn:["layer.visible"]})],t.prototype,"visible",null),n([u.property({dependsOn:["layer.opacity","parent.fullOpacity"]})],t.prototype,"fullOpacity",null),n([u.subclass("esri.views.layers.LayerView")],t)}(u.declared(o,r,a.Identifiable,l))}.apply(null,n))||(e.exports=r)},1520:function(e,t,i){var n,r;n=[i.dj.c(e.i),t],void 0===(r=function(e,t){return function(){function e(e,t,i,n){this._tag=0,this._dataType=99,this._data=e,this._dataView=t,this._pos=i||0,this._end=n||e.byteLength}return e.prototype.clone=function(){return new e(this._data,this._dataView,this._pos,this._end)},e.prototype.pos=function(){return this._pos},e.prototype.next=function(e){for(;;){if(this._pos===this._end)return!1;var t=this._decodeVarint();if(this._tag=t>>3,this._dataType=7&t,!e||e===this._tag)break;this.skip()}return!0},e.prototype.empty=function(){return this._pos>=this._end},e.prototype.tag=function(){return this._tag},e.prototype.getInt32=function(){return this._decodeVarint()},e.prototype.getInt64=function(){return this._decodeVarint()},e.prototype.getUInt32=function(){var e=4294967295;return e=(127&this._data[this._pos])>>>0,this._data[this._pos++]<128?e:(e=(e|(127&this._data[this._pos])<<7)>>>0,this._data[this._pos++]<128?e:(e=(e|(127&this._data[this._pos])<<14)>>>0,this._data[this._pos++]<128?e:(e=(e|(127&this._data[this._pos])<<21)>>>0,this._data[this._pos++]<128?e:(e=(e|(15&this._data[this._pos])<<28)>>>0,this._data[this._pos++]<128?e:void 0))))},e.prototype.getUInt64=function(){return this._decodeVarint()},e.prototype.getSInt32=function(){var e=this.getUInt32();return e>>>1^-(1&e)|0},e.prototype.getSInt64=function(){return this._decodeSVarint()},e.prototype.getBool=function(){var e=0!==this._data[this._pos];return this._skip(1),e},e.prototype.getEnum=function(){return this._decodeVarint()},e.prototype.getFixed64=function(){var e=this._dataView,t=this._pos,i=e.getUint32(t,!0)+4294967296*e.getUint32(t+4,!0);return this._skip(8),i},e.prototype.getSFixed64=function(){var e=this._dataView,t=this._pos,i=e.getUint32(t,!0)+4294967296*e.getInt32(t+4,!0);return this._skip(8),i},e.prototype.getDouble=function(){var e=this._dataView.getFloat64(this._pos,!0);return this._skip(8),e},e.prototype.getFixed32=function(){var e=this._dataView.getUint32(this._pos,!0);return this._skip(4),e},e.prototype.getSFixed32=function(){var e=this._dataView.getInt32(this._pos,!0);return this._skip(4),e},e.prototype.getFloat=function(){var e=this._dataView.getFloat32(this._pos,!0);return this._skip(4),e},e.prototype.getString=function(){var e=this._getLength(),t=this._pos,i=this._toString(this._data,t,t+e);return this._skip(e),i},e.prototype.getBytes=function(){var e=this._getLength(),t=this._pos,i=this._toBytes(this._data,t,t+e);return this._skip(e),i},e.prototype.getMessage=function(){var t=this._getLength(),i=this._pos,n=new e(this._data,this._dataView,i,i+t);return this._skip(t),n},e.prototype.skip=function(){switch(this._dataType){case 0:this._decodeVarint();break;case 1:this._skip(8);break;case 2:this._skip(this._getLength());break;case 5:this._skip(4);break;default:throw new Error("Invalid data type!")}},e.prototype._skip=function(e){if(this._pos+e>this._end)throw new Error("Attempt to skip past the end of buffer!");this._pos+=e},e.prototype._decodeVarint=function(){var e,t=this._data,i=this._pos,n=0;if(this._end-i>=10)do{if(n|=127&(e=t[i++]),0==(128&e))break;if(n|=(127&(e=t[i++]))<<7,0==(128&e))break;if(n|=(127&(e=t[i++]))<<14,0==(128&e))break;if(n|=(127&(e=t[i++]))<<21,0==(128&e))break;if(n+=268435456*(127&(e=t[i++])),0==(128&e))break;if(n+=34359738368*(127&(e=t[i++])),0==(128&e))break;if(n+=4398046511104*(127&(e=t[i++])),0==(128&e))break;if(n+=562949953421312*(127&(e=t[i++])),0==(128&e))break;if(n+=72057594037927940*(127&(e=t[i++])),0==(128&e))break;if(n+=0x8000000000000000*(127&(e=t[i++])),0==(128&e))break;throw new Error("Varint too long!")}while(0);else{for(var r=1;i!==this._end&&0!=(128&(e=t[i]));)++i,n+=(127&e)*r,r*=128;if(i===this._end)throw new Error("Varint overrun!");++i,n+=e*r}return this._pos=i,n},e.prototype._decodeSVarint=function(){var e=this._decodeVarint();return e%2?-(e+1)/2:e/2},e.prototype._getLength=function(){if(2!==this._dataType)throw new Error("Not a delimited data type!");return this._decodeVarint()},e.prototype._toString=function(e,t,i){var n="",r="";i=Math.min(this._end,i);for(var o=t;o<i;++o){var a=e[o];128&a?r+="%"+a.toString(16):(n+=decodeURIComponent(r)+String.fromCharCode(a),r="")}return r.length&&(n+=decodeURIComponent(r)),n},e.prototype._toBytes=function(e,t,i){return i=Math.min(this._end,i),new Uint8Array(e.buffer,t,i-t)},e}()}.apply(null,n))||(e.exports=r)},1608:function(e,t,i){var n,r;n=[i.dj.c(e.i),t],void 0===(r=function(e,t){Object.defineProperty(t,"__esModule",{value:!0});var i=new Uint32Array(1),n=new Uint8Array(i.buffer);t.int32To4Bytes=function(e){return i[0]=0|e,[n[0],n[1],n[2],n[3]]}}.apply(null,n))||(e.exports=r)},1648:function(e,t,i){var n,r;n=[i.dj.c(e.i),t],void 0===(r=function(e,t){return function(){function e(e){this._array=[],e<=0&&console.error("strideInBytes must be positive!"),this._stride=e}return Object.defineProperty(e.prototype,"array",{get:function(){return this._array},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"index",{get:function(){return 4*this._array.length/this._stride},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"itemSize",{get:function(){return this._stride},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"sizeInBytes",{get:function(){return 4*this._array.length},enumerable:!0,configurable:!0}),e.prototype.reset=function(){this.array.length=0},e.prototype.toBuffer=function(){return new Uint32Array(this._array).buffer},e.i1616to32=function(e,t){return 65535&e|t<<16},e.i8888to32=function(e,t,i,n){return 255&e|(255&t)<<8|(255&i)<<16|n<<24},e.i8816to32=function(e,t,i){return 255&e|(255&t)<<8|i<<16},e}()}.apply(null,n))||(e.exports=r)},1689:function(e,t,i){var n,r;n=[i.dj.c(e.i),t],void 0===(r=function(e,t){return function(){function e(e,t,i,n){void 0===e&&(e=0),void 0===t&&(t=0),void 0===i&&(i=0),void 0===n&&(n=0),this.x=e,this.y=t,this.width=i,this.height=n}return Object.defineProperty(e.prototype,"isEmpty",{get:function(){return this.width<=0||this.height<=0},enumerable:!0,configurable:!0}),e}()}.apply(null,n))||(e.exports=r)},1782:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(50),i(19),i(583),i(9),i(356),i(355),i(352),i(545),i(2183),i(2184),i(2185),i(611),i(277),i.dj.m(e)],void 0===(r=function(e,t,i,n,r,o,a,s,l,d,u,f,c,h,_,p){var v=new r(10),m=new Map;return function(){function t(e,t,i,n){this.devicePixelRatio=t,this.allowUpdates=i,this._spriteMosaic=null,this._glyphMosaic=null,this._connection=null,this._updateQueue=new Map,this._ongoingRequests=new Map,this._vectorTileLayer=e,this._container=n}return t.prototype.destroy=function(){this.stop(),this._vectorTileLayer=null,this._spriteMosaic&&(this._spriteMosaic.dispose(),this._spriteMosaic=null),this._glyphMosaic&&(this._glyphMosaic.dispose(),this._glyphMosaic=null)},Object.defineProperty(t.prototype,"initialized",{get:function(){return this._broadcastPromise&&this._broadcastPromise.isFulfilled()},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"spriteMosaic",{get:function(){return this._spriteMosaic},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"glyphMosaic",{get:function(){return this._glyphMosaic},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"ongoingRequestCount",{get:function(){return this._ongoingRequests.size},enumerable:!0,configurable:!0}),t.prototype.start=function(){var t=this;this.stop();var i=[],r=this._vectorTileLayer.loadSpriteSource(this.devicePixelRatio).then(function(e){t._spriteMosaic=new c(1024,1024,250),t._spriteMosaic.setSpriteSource(e),n("stable-symbol-rendering")&&t._spriteMosaic.preloadSpriteItems()});i.push(r);var l=this._vectorTileLayer.styleRepository,d=new f(l.glyphs);this._glyphMosaic=new u(1024,1024,d);var h=this._vectorTileLayer.sourceNameToSource;for(var _ in h)i.push(this._fetchTileMap(h[_]));var v=s.open(a.getAbsMid("./WorkerTileHandler",e,p),{client:this}).then(function(e){t._connection=e});return i.push(v),this._broadcastPromise=o.all(i).then(function(){return t._connection.broadcast("setLayers",l.styleJSON)}),this._broadcastPromise},t.prototype.stop=function(){this._broadcastPromise&&!this._broadcastPromise.isFulfilled()&&this._broadcastPromise.cancel(),this._updateQueue.forEach(function(e){return e.cancel()}),this._ongoingRequests.forEach(function(e){return e.cancel()}),this._connection&&(this._connection.close(),this._connection=null)},t.prototype.updateStyle=function(){this._updateQueue.forEach(function(e){return e.cancel()}),this._updateQueue.clear(),this._ongoingRequests.forEach(function(e){return e.cancel()}),this._ongoingRequests.clear();var e,t=this._vectorTileLayer.styleRepository,i=o.create(function(t){e=t});return o.all(this._connection.broadcast("updateStyle",t.styleJSON)).then(function(){return e()}),this._broadcastPromise=i,i},t.prototype.updateTile=function(e,t){var i=this;if(!this.allowUpdates)return o.resolve(null);if(!this._broadcastPromise.isFulfilled()||!this._connection)return o.reject(new Error("no connection"));var n=Math.round(d.degToByte(t.state.rotation));if(e.rotation===n)return o.resolve(null);var r,a=e.key;return this._updateQueue.has(a.id)&&((r=this._updateQueue.get(a.id)).cancel(),this._updateQueue.delete(a.id)),e.rotation=n,r=e.client.invoke("updateSymbols",{key:e.id,rotation:n}).then(function(t){return i._updateQueue.delete(a.id),e.updateSymbolData(t),t}).catch(function(e){"cancel"!==e.dojoType&&i._updateQueue.delete(a.id)}),this._updateQueue.set(e.id,r),r},t.prototype.updateTileData=function(e){for(var t,i=e.tileId,n=this._container.children,r=0;r<n.length;r++)if((t=n[r]).id===i){t.updateTileData(e.tileData);break}},t.prototype.getVectorTile=function(e,t,i,n){void 0===n&&(n=0);var r=new l(e,t,i,0),a=new _(r,this._vectorTileLayer.tileInfo,this._vectorTileLayer.styleRepository,0),s=this.getTileData(r,0).then(function(e){return e?a.setData(e.tileData,e.client):a.setData(null,null),a});return o.create(function(e,t){s.then(function(t){return e(t)}).catch(function(e){return t(e)})})},t.prototype.getTileData=function(e,t){var i=this;if(!this._broadcastPromise.isFulfilled()||!this._connection)return o.reject(new Error("no connection"));var n=e.id;if(this._ongoingRequests.has(n))return this._ongoingRequests.get(n);var r=this._vectorTileLayer.sourceNameToSource,a=[],s=[];for(var l in r){var u=r[l],f=u.getRefKey(e);a.push(f),s.push(u.name)}var c=!1,h=o.eachAlways(a).then(function(r){for(var a=Math.round(d.degToByte(t)),l=[],u=0;u<r.length;u++)if(null==r[u].value)l.push(o.reject("getRefKey failed for source "+s[u]));else{var f=i._getTileData(e,r[u].value,s[u]).then(function(e){return e&&e.protobuff?e:(c=!0,i._ongoingRequests.delete(n),o.reject())});l.push(f)}return o.eachAlways(l).then(function(t){for(var s={},l=[],d=0;d<t.length;d++)if(t[d].value&&t[d].value.protobuff&&t[d].value.protobuff.byteLength>0){var u=r[d].value.toString();s[t[d].value.sourceName]={refKey:u,protobuff:t[d].value.protobuff},l.push(t[d].value.protobuff)}if(0===Object.keys(s).length)return c=!0,i._ongoingRequests.delete(n),o.resolve(null);var f=i._connection.getAvailableClient();return f.invoke("createTileAndParse",{key:e.toString(),rotation:a,cacheTile:i.allowUpdates,sourceName2DataAndRefKey:s},{transferList:l}).then(function(e){return c=!0,i._ongoingRequests.delete(n),{tileData:e,client:f}}).catch(function(t){return c=!0,i._ongoingRequests.delete(n),f.invoke("destructTileData",e.id),o.reject(t)})}).catch(function(e){return i._ongoingRequests.delete(n),o.reject(e)})}).catch(function(e){return i._ongoingRequests.delete(n),o.reject(e)});return c||this._ongoingRequests.set(n,h),h},t.prototype.getSprites=function(e){return this._spriteMosaic.getSpriteItems(e)},t.prototype.getGlyphs=function(e){return this._glyphMosaic.getGlyphItems(e.tileID,e.font,e.codePoints)},t.prototype.getStyleRepository=function(){return this._vectorTileLayer.styleRepository},t.prototype._getTileData=function(e,t,i){return this.fetchTileData(t.toString(),i).then(function(e){return{protobuff:e,sourceName:i}})},t.prototype._fetchTileMap=function(e){if(e.capabilities.operations.supportsTileMap&&e.tileIndex)return o.resolve();if(!e.tileMapURL)return o.resolve();var t=v.get(e.tileMapURL);if(t)return e.tileIndex=t,o.resolve();if(m.has(e.tileMapURL))return m.get(e.tileMapURL).then(function(t){e.tileIndex=new h(t.data)});var n=i(e.tileMapURL,{responseType:"json"});return n.then(function(t){e.tileIndex=new h(t.data),m.delete(e.tileMapURL),v.put(e.tileMapURL,e.tileIndex)}),m.set(e.tileMapURL,n),n},t.prototype.fetchTileData=function(e,t){var n=l.pool.acquire(e),r=this._vectorTileLayer.sourceNameToSource;if(!(t in r))return l.pool.release(n),o.reject(new Error("invalid source name"));var a=r[t].getSourceTileUrl(n.level,n.row,n.col);return l.pool.release(n),i(a,{responseType:"array-buffer"}).then(function(e){return e.data})},t}()}.apply(null,n))||(e.exports=r)},1783:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(1689)],void 0===(r=function(e,t,i){return function(){function e(e,t){this._width=0,this._height=0,this._free=[],this._width=e,this._height=t,this._free.push(new i(0,0,e,t))}return Object.defineProperty(e.prototype,"width",{get:function(){return this._width},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"height",{get:function(){return this._height},enumerable:!0,configurable:!0}),e.prototype.allocate=function(e,t){if(e>this._width||t>this._height)return new i;for(var n=null,r=-1,o=0;o<this._free.length;++o){var a=this._free[o];e<=a.width&&t<=a.height&&(null===n||a.y<=n.y&&a.x<=n.x)&&(n=a,r=o)}return null===n?new i:(this._free.splice(r,1),n.width<n.height?(n.width>e&&this._free.push(new i(n.x+e,n.y,n.width-e,t)),n.height>t&&this._free.push(new i(n.x,n.y+t,n.width,n.height-t))):(n.width>e&&this._free.push(new i(n.x+e,n.y,n.width-e,n.height)),n.height>t&&this._free.push(new i(n.x,n.y+t,e,n.height-t))),new i(n.x,n.y,e,t))},e.prototype.release=function(e){for(var t=0;t<this._free.length;++t){var i=this._free[t];if(i.y===e.y&&i.height===e.height&&i.x+i.width===e.x)i.width+=e.width;else if(i.x===e.x&&i.width===e.width&&i.y+i.height===e.y)i.height+=e.height;else if(e.y===i.y&&e.height===i.height&&e.x+e.width===i.x)i.x=e.x,i.width+=e.width;else{if(e.x!==i.x||e.width!==i.width||e.y+e.height!==i.y)continue;i.y=e.y,i.height+=e.height}this._free.splice(t,1),this.release(e)}this._free.push(e)},e}()}.apply(null,n))||(e.exports=r)},1784:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(18),i(264),i(262),i(361),i(2187),i(545),i(2191),i(2192),i(2193),i(2194),i(2195),i(2196),i(2199),i(2200),i(110)],void 0===(r=function(e,t,i,n,r,o,a,s,l,d,u,f,c,h,_,p,v){return function(){function e(){this._extrudeMatrix=n.mat4f32.create(),this._extrudeNoRotationMatrix=n.mat4f32.create(),this._extrudeRotateVector=r.vec3f32.fromValues(0,0,1),this._extrudeScaleVector=r.vec3f32.fromValues(1,1,1),this._backgroundColor=o.vec4f32.fromValues(1,0,0,1),this._state={rotation:0,size:[0,0]},this._cachedWidth=0,this._cachedHeight=0,this._cachedRotation=0,this._blitRenderer=new a,this._globalOpacityFBO=null,this._boundFBO=null,this._programCache=null}return e.prototype.initialize=function(e,t,i){void 0===i&&(i=!0),this._SpriteMosaic=e,this._glyphMosaic=t,this._ignoreSpeed=!i,this._fadeRecorder=new u.FadeRecorder(300)},e.prototype.dispose=function(){this._backgroundRenderer&&(this._backgroundRenderer.dispose(),this._backgroundRenderer=null),this._lineRenderer&&(this._lineRenderer.dispose(),this._lineRenderer=null),this._fillRenderer&&(this._fillRenderer.dispose(),this._fillRenderer=null),this._symbolRenderer&&(this._symbolRenderer.dispose(),this._symbolRenderer=null),this._circleRenderer&&(this._circleRenderer.dispose(),this._circleRenderer=null),this._tileInfoRenderer&&(this._tileInfoRenderer.dispose(),this._tileInfoRenderer=null),this._hittestFBO&&(this._hittestFBO.dispose(),this._hittestFBO=null),this._globalOpacityFBO&&(this._globalOpacityFBO.dispose(),this._globalOpacityFBO=null),this._blitRenderer&&(this._blitRenderer.dispose(),this._blitRenderer=null),this._boundFBO=null,this._programCache&&(this._programCache.dispose(),this._programCache=null),this._cachedWidth=0,this._cachedHeight=0,this._cachedRotation=0},e.prototype.initializeProgramCache=function(e){if(null===this._programCache){var t=new p.default;t.initialize(e),this._backgroundRenderer=new l(t),this._lineRenderer=new c(t),this._fillRenderer=new f(t),this._symbolRenderer=new h(t),this._circleRenderer=new d(t),this._tileInfoRenderer=new _(t),this._programCache=t}},e.prototype.setStateParams=function(e,t,n){this._fadeRecorder.recordLevel(n),this._state=e,this._state.size[0]===this._cachedWidth&&this._state.size[1]===this._cachedHeight&&this._state.rotation===this._cachedRotation||(this._extrudeScaleVector[0]=2/e.size[0],this._extrudeScaleVector[1]=-2/e.size[1],i.mat4.identity(this._extrudeMatrix),i.mat4.rotate(this._extrudeMatrix,this._extrudeMatrix,-e.rotation*s.C_DEG_TO_RAD,this._extrudeRotateVector),i.mat4.scale(this._extrudeMatrix,this._extrudeMatrix,this._extrudeScaleVector),i.mat4.transpose(this._extrudeMatrix,this._extrudeMatrix),i.mat4.identity(this._extrudeNoRotationMatrix),i.mat4.scale(this._extrudeNoRotationMatrix,this._extrudeNoRotationMatrix,this._extrudeScaleVector),i.mat4.transpose(this._extrudeNoRotationMatrix,this._extrudeNoRotationMatrix),this._cachedWidth=this._state.size[0],this._cachedHeight=this._state.size[1],this._cachedRotation=this._state.rotation)},e.prototype.drawClippingMasks=function(e,t){if(0!==t.length){e.setDepthWriteEnabled(!1),e.setDepthTestEnabled(!1),e.setStencilTestEnabled(!0),e.setBlendingEnabled(!1),e.setColorMask(!1,!1,!1,!1),e.setStencilOp(7680,7680,7681),e.setStencilWriteMask(255),e.setClearStencil(0);var i=e.gl;e.clear(i.STENCIL_BUFFER_BIT);for(var n=0,r=t;n<r.length;n++){var o=r[n];o.attached&&o.visible&&(e.setStencilFunctionSeparate(1032,519,o.stencilData.reference,o.stencilData.mask),this._backgroundRenderer.renderSolidColor(e,{u_matrix:o.tileTransform.transform,u_normalized_origin:o.tileTransform.displayCoord,u_coord_range:o.coordRange,u_depth:0,u_color:this._backgroundColor}))}e.setColorMask(!0,!0,!0,!0),e.setBlendingEnabled(!0)}},e.prototype.renderDebug=function(e,t){var i=t.key;this._backgroundColor.set([i.col%2,i.row%2,i.col%2==0&&i.row%2==0?1:0,.5]),this._backgroundRenderer.renderSolidColor(e,{u_matrix:t.tileTransform.transform,u_normalized_origin:t.tileTransform.displayCoord,u_coord_range:t.coordRange,u_depth:0,u_color:this._backgroundColor})},e.prototype.renderBucket=function(e,t,i,n,r,o,a,s){if(a&&!(void 0!==a.minzoom&&a.minzoom>i+1e-6||o.key.level===n&&void 0!==a.maxzoom&&a.maxzoom<=i-1e-6))switch(t.type){case 0:2!==r&&this._renderBackground(e,t,i,r,o,a,s);break;case 1:2!==r&&this._renderFill(e,t,i,r,o,a,s);break;case 2:1!==r&&3!==r||this._renderLine(e,t,i,r,o,a,s);break;case 3:2!==r&&3!==r||this._renderSymbol(e,t,i,r,n,o,a,s);break;case 4:2!==r&&3!==r||this._renderCircle(e,t,i,r,n,o,a,s)}},e.prototype.renderTileInfo=function(e,t){this._tileInfoRenderer.render(e,t)},e.prototype.setGlobalOpacity=function(e,t,i){if(1!==i){this._boundFBO=e.getBoundFramebufferObject();var n=t.pixelRatio,r=t.state.size,o=r[0],a=r[1],s=Math.round(o*n),l=Math.round(a*n);null!==this._globalOpacityFBO&&this._globalOpacityFBO.width===s&&this._globalOpacityFBO.height===l||(null!==this._globalOpacityFBO&&this._globalOpacityFBO.dispose(),this._globalOpacityFBO=v.create(e,{colorTarget:0,depthStencilTarget:3,width:s,height:l})),e.bindFramebuffer(this._globalOpacityFBO),e.setClearColor(0,0,0,0),e.clear(e.gl.COLOR_BUFFER_BIT)}},e.prototype.applyGlobalOpacity=function(e,t,i){if(1!==i){var n=t.pixelRatio,r=t.state.size,o=r[0],a=r[1],s=e.getViewport();e.setViewport(0,0,n*o,n*a),e.bindFramebuffer(this._boundFBO);var l=this._globalOpacityFBO.colorTexture;this._blitRenderer.render(e,l,9728,i),e.setViewport(s.x,s.y,s.width,s.height),this._boundFBO=null}},e.prototype.needsRedraw=function(){return this._fadeRecorder.needsRedraw()},e.prototype.hitTest=function(e,t,i,n,r,o,a){var s=[0,0],l=[0,0],d=e.state;d.toMap(s,[0,0]),d.toMap(l,[o,o]);var u=n.filter(function(e){return!(s[0]>e.bounds[2]||l[0]<e.bounds[0]||s[1]<e.bounds[3]||l[1]>e.bounds[1])});if(0===u.length)return[];u.sort(function(e,t){return e.key.level-t.key.level});for(var f=u.length,c=1;c<=f;c++){(y=u[c-1]).attached&&(y.stencilData.reference=c,y.stencilData.mask=255)}a(d,r,u);var h=e.context;this._hittestFBO||(this._hittestFBO=v.create(h,{colorTarget:0,depthStencilTarget:3,width:o,height:o}));var _=h.getViewport(),p=h.getBoundFramebufferObject();h.bindFramebuffer(this._hittestFBO),h.setViewport(0,0,o,o);var m=h.gl;h.setDepthWriteEnabled(!0),h.setStencilWriteMask(255),h.setClearColor(1,1,1,1),h.setClearDepth(1),h.setClearStencil(0),h.clear(m.COLOR_BUFFER_BIT|m.DEPTH_BUFFER_BIT|m.STENCIL_BUFFER_BIT),h.setDepthWriteEnabled(!1),this.drawClippingMasks(h,u),h.setBlendingEnabled(!1),h.setStencilWriteMask(0),h.setStencilOp(7680,7680,7681),h.setDepthFunction(515),h.setDepthTestEnabled(!0),h.setDepthWriteEnabled(!0),h.setStencilTestEnabled(!0);for(var g=0;g<f;g++){var y;(y=u[g]).attached&&y.doRender(e)}h.setStencilTestEnabled(!1),h.setDepthTestEnabled(!1),this._readbackBuffer||(this._readbackBuffer=new Uint8Array(4*o*o),this._readbackBuffer32=new Uint32Array(this._readbackBuffer.buffer)),this._hittestFBO.readPixels(0,0,o,o,6408,5121,this._readbackBuffer);var x=new Set,b=o*o,w=Math.round(b/2),D=this._readbackBuffer32[w];4294967295!==D&&x.add(D);for(c=0;c<b;c++)4294967295!==(D=this._readbackBuffer32[c])&&x.add(D);h.bindFramebuffer(p),h.setViewport(_.x,_.y,_.width,_.height);var V=[];return x.forEach(function(e){V.push(e)}),V},e.prototype._renderBackground=function(e,t,i,n,r,o,a){this._backgroundRenderer.render(e,t,i,n,r,o,this._SpriteMosaic,this._SpriteMosaic.pixelRatio,a)},e.prototype._renderLine=function(e,t,i,n,r,o,a){this._lineRenderer.render(e,t,i,n,this._state,r,o,this._SpriteMosaic,this._extrudeMatrix,this._SpriteMosaic.pixelRatio,a)},e.prototype._renderFill=function(e,t,i,n,r,o,a){this._fillRenderer.render(e,t,i,this._state.rotation,n,r,o,this._SpriteMosaic,this._extrudeMatrix,this._SpriteMosaic.pixelRatio,a)},e.prototype._renderCircle=function(e,t,i,n,r,o,a,s){var l=!0;r===o.key.level&&(l=!1),e.setStencilTestEnabled(l),this._circleRenderer.render(e,t,i,n,this._state.rotation,o,a,this._extrudeMatrix,s)},e.prototype._renderSymbol=function(e,t,i,n,r,o,a,s){var l=!0;r===o.key.level&&(l=!1),e.setStencilTestEnabled(l),this._symbolRenderer.render(e,t,i,n,this._state.rotation,this._fadeRecorder.getFadeValues(this._ignoreSpeed),o,a,this._SpriteMosaic,this._glyphMosaic,this._extrudeMatrix,this._extrudeNoRotationMatrix,this._SpriteMosaic.pixelRatio,s)},e}()}.apply(null,n))||(e.exports=r)},2183:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(19),i(9),i(1689),i(1783),i(53)],void 0===(r=function(e,t,i,n,r,o,a){var s;return function(){function e(e,t,n){this.width=0,this.height=0,this._dirties=[],this._glyphData=[],this._currentPage=0,this._glyphIndex={},this._textures=[],this._rangePromises=new Map,!s&&i("stable-symbol-rendering")&&(s=new Set),this.width=e,this.height=t,this._glyphSource=n,this._binPack=new o(e-4,t-4),this._glyphData.push(new Uint8Array(e*t)),this._dirties.push(!0),this._textures.push(void 0)}return e.prototype.getGlyphItems=function(e,t,a){for(var l=this,d=[],u=this._glyphSource,f=new Set,c=0,h=a;c<h.length;c++){var _=h[c],p=Math.floor(_*(1/256));f.add(p)}var v=[];return f.forEach(function(e){if(e<=256){var i=t+e;if(l._rangePromises.has(i))v.push(l._rangePromises.get(i));else{var n=u.getRange(t,e).then(function(){l._rangePromises.delete(i)},function(){l._rangePromises.delete(i)});l._rangePromises.set(i,n),v.push(n)}}}),n.all(v).then(function(e){var n,c=l._glyphIndex[t];if(c||(c={},l._glyphIndex[t]=c),i("stable-symbol-rendering")){s.clear();for(var h=0,_=a;h<_.length;h++){var p=_[h];s.add(p)}var v=[];f.forEach(function(e){v.push(e)}),v.sort(),n=[];for(var m=0,g=v;m<g.length;m++)for(var y=g[m],x=0;x<256;++x)n.push(256*y+x)}else n=a;for(var b=0,w=n;b<w.length;b++){var D=c[p=w[b]];if(D)i("stable-symbol-rendering")&&!s.has(p)||(d[p]={sdf:!0,rect:D.rect,metrics:D.metrics,page:D.page});else{var V=u.getGlyph(t,p);if(V&&V.metrics){var z=V.metrics,T=void 0;if(0===z.width)T=new r(0,0,0,0);else{var S=z.width+6,I=z.height+6,O=S%4?4-S%4:4,C=I%4?4-I%4:4;1===O&&(O=5),1===C&&(C=5),(T=l._binPack.allocate(S+O,I+C)).isEmpty&&(l._dirties[l._currentPage]||(l._glyphData[l._currentPage]=null),l._currentPage=l._glyphData.length,l._glyphData.push(new Uint8Array(l.width*l.height)),l._dirties.push(!0),l._textures.push(void 0),l._binPack=new o(l.width-4,l.height-4),T=l._binPack.allocate(S+O,I+C));var A=l._glyphData[l._currentPage],M=V.bitmap,P=void 0,R=void 0;if(M)for(var F=0;F<I;F++){P=S*F,R=l.width*(T.y+F+1)+T.x;for(var E=0;E<S;E++)A[R+E+1]=M[P+E]}}c[p]={rect:T,metrics:z,tileIDs:null,page:l._currentPage},i("stable-symbol-rendering")&&!s.has(p)||(d[p]={sdf:!0,rect:T,metrics:z,page:l._currentPage}),l._dirties[l._currentPage]=!0}}}return d})},e.prototype.removeGlyphs=function(e){for(var t in this._glyphIndex){var i=this._glyphIndex[t];if(i){var n=void 0;for(var r in i)if((n=i[r]).tileIDs.delete(e),0===n.tileIDs.size){for(var o=this._glyphData[n.page],a=n.rect,s=void 0,l=void 0,d=0;d<a.height;d++)for(s=this.width*(a.y+d)+a.x,l=0;l<a.width;l++)o[s+l]=0;delete i[r],this._dirties[n.page]=!0}}}},e.prototype.bind=function(e,t,i,n){void 0===n&&(n=0),this._textures[i]||(this._textures[i]=new a(e,{pixelFormat:6406,dataType:5121,width:this.width,height:this.height},new Uint8Array(this.width*this.height)));var r=this._textures[i];r.setSamplingMode(t),this._dirties[i]&&r.setData(this._glyphData[i]),e.bindTexture(r,n),this._dirties[i]=!1},e.prototype.dispose=function(){this._binPack=null;for(var e=0,t=this._textures;e<t.length;e++){var i=t[e];i&&i.dispose()}this._textures.length=0},e}()}.apply(null,n))||(e.exports=r)},2184:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(50),i(1520),i(9)],void 0===(r=function(e,t,i,n,r){var o=function(){function e(e){if(this._metrics=[],this._bitmaps=[],e)for(;e.next();)switch(e.tag()){case 1:for(var t=e.getMessage();t.next();)switch(t.tag()){case 3:for(var i=t.getMessage(),n=void 0,r=void 0,o=void 0,a=void 0,s=void 0,l=void 0,d=void 0;i.next();)switch(i.tag()){case 1:n=i.getUInt32();break;case 2:r=i.getBytes();break;case 3:o=i.getUInt32();break;case 4:a=i.getUInt32();break;case 5:s=i.getSInt32();break;case 6:l=i.getSInt32();break;case 7:d=i.getUInt32();break;default:i.skip()}n&&(this._metrics[n]={width:o,height:a,left:s,top:l,advance:d},this._bitmaps[n]=r);break;default:t.skip()}break;default:e.skip()}}return e.prototype.getMetrics=function(e){return this._metrics[e]},e.prototype.getBitmap=function(e){return this._bitmaps[e]},e}(),a=function(){function e(){this._ranges=[]}return e.prototype.getRange=function(e){return this._ranges[e]},e.prototype.addRange=function(e,t){this._ranges[e]=t},e}();return function(){function e(e){this._glyphInfo={},this._baseURL=e}return e.prototype.getRange=function(e,t){var a=this._getFontStack(e);if(a.getRange(t))return r.resolve();var s=256*t,l=s+255,d=this._baseURL.replace("{fontstack}",e).replace("{range}",s+"-"+l);return i(d,{responseType:"array-buffer"}).then(function(e){a.addRange(t,new o(new n(new Uint8Array(e.data),new DataView(e.data))))}).catch(function(){a.addRange(t,new o)})},e.prototype.getGlyph=function(e,t){var i=this._getFontStack(e);if(i){var n=Math.floor(t/256);if(!(n>256)){var r=i.getRange(n);if(r)return{metrics:r.getMetrics(t),bitmap:r.getBitmap(t)}}}},e.prototype._getFontStack=function(e){var t=this._glyphInfo[e];return t||(t=this._glyphInfo[e]=new a),t},e}()}.apply(null,n))||(e.exports=r)},2185:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(545),i(1689),i(1783),i(53)],void 0===(r=function(e,t,i,n,r,o){return function(){function e(e,t,i){void 0===i&&(i=0),this._size=[],this._mosaicsData=[],this._textures=[],this._dirties=[],this._maxItemSize=0,this._currentPage=0,this._pageWidth=0,this._pageHeight=0,this._mosaicRects={},this.pixelRatio=1,(e<=0||t<=0)&&console.error("Sprites mosaic defaultWidth and defaultHeight must be greater than zero!"),this._pageWidth=e,this._pageHeight=t,i>0&&(this._maxItemSize=i),this._binPack=new r(e-4,t-4)}return e.prototype.getWidth=function(e){return e>=this._size.length?-1:this._size[e][0]},e.prototype.getHeight=function(e){return e>=this._size.length?-1:this._size[e][1]},e.prototype.setSpriteSource=function(e){if(this.dispose(),this.pixelRatio=e.devicePixelRatio,0===this._mosaicsData.length){this._binPack=new r(this._pageWidth-4,this._pageHeight-4);var t=Math.floor(this._pageWidth),i=Math.floor(this._pageHeight),n=new Uint32Array(t*i);this._mosaicsData[0]=n,this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0)}this._sprites=e},e.prototype.getSpriteItem=function(e,t){void 0===t&&(t=!1);var i=this._mosaicRects[e];if(i)return i;if(!this._sprites||"loaded"!==this._sprites.loadStatus)return null;var n=this._sprites.getSpriteInfo(e);if(!n||!n.width||!n.height||n.width<0||n.height<0)return null;var r=n.width,o=n.height,a=this._allocateImage(r,o),s=a[0],l=a[1],d=a[2];return s.width<=0?null:(this._copy(s,n,l,d,t),i={rect:s,width:r,height:o,anchorX:0,anchorY:0,sdf:n.sdf,simplePattern:!1,pixelRatio:n.pixelRatio,page:l},this._mosaicRects[e]=i,i)},e.prototype.preloadSpriteItems=function(){for(var e=0,t=this._sprites.spriteNames;e<t.length;e++){var i=t[e];this.getSpriteItem(i,!0)}},e.prototype.getSpriteItems=function(e){for(var t={},i=0,n=e;i<n.length;i++){var r=n[i];t[r]=this.getSpriteItem(r)}return t},e.prototype.getMosaicItemPosition=function(e,t){var i=this.getSpriteItem(e,t),n=i&&i.rect;if(!n)return null;n.width=i.width,n.height=i.height;var r=i.width,o=i.height;return{size:[i.width,i.height],tl:[(n.x+2)/this._size[i.page][0],(n.y+2)/this._size[i.page][1]],br:[(n.x+2+r)/this._size[i.page][0],(n.y+2+o)/this._size[i.page][1]],page:i.page}},e.prototype.bind=function(e,t,i,n){void 0===i&&(i=0),void 0===n&&(n=0),this._textures[i]||(this._textures[i]=new o(e,{pixelFormat:6408,dataType:5121,width:this._size[i][0],height:this._size[i][1]},new Uint8Array(this._mosaicsData[i].buffer)));var r=this._textures[i];r.setSamplingMode(t),this._dirties[i]&&r.setData(new Uint8Array(this._mosaicsData[i].buffer)),e.bindTexture(r,n),this._dirties[i]=!1},e._copyBits=function(e,t,i,n,r,o,a,s,l,d,u){var f=n*t+i,c=s*o+a;if(u){c-=o;for(var h=-1;h<=d;f=((++h+d)%d+n)*t+i,c+=o)for(var _=-1;_<=l;_++)r[c+_]=e[f+(_+l)%l]}else for(h=0;h<d;h++){for(_=0;_<l;_++)r[c+_]=e[f+_];f+=t,c+=o}},e.prototype._copy=function(t,i,n,r,o,a){if(this._sprites&&"loaded"===this._sprites.loadStatus&&!(n>=this._mosaicsData.length)){var s=new Uint32Array(a?a.buffer:this._sprites.image.buffer),l=this._mosaicsData[n];l&&s||console.error("Source or target images are uninitialized!");var d=a?i.width:this._sprites.width;e._copyBits(s,d,i.x,i.y,l,r[0],t.x+2,t.y+2,i.width,i.height,o),this._dirties[n]=!0}},e.prototype._allocateImage=function(e,t){e+=2,t+=2;var o=Math.max(e,t);if(this._maxItemSize&&this._maxItemSize<o){var a=Math.pow(2,Math.ceil(i.log2(e))),s=Math.pow(2,Math.ceil(i.log2(t))),l=new n(0,0,e,t);return this._mosaicsData.push(new Uint32Array(a*s)),this._dirties.push(!0),this._size.push([a,s]),this._textures.push(void 0),[l,this._mosaicsData.length-1,[a,s]]}var d=e%4?4-e%4:4,u=t%4?4-t%4:4;1===d&&(d=5),1===u&&(u=5);var f=this._binPack.allocate(e+d,t+u);return f.width<=0?(this._dirties[this._currentPage]||(this._mosaicsData[this._currentPage]=null),this._currentPage=this._mosaicsData.length,this._mosaicsData.push(new Uint32Array(this._pageWidth*this._pageHeight)),this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0),this._binPack=new r(this._pageWidth-4,this._pageHeight-4),this._allocateImage(e,t)):[f,this._currentPage,[this._pageWidth,this._pageHeight]]},e.prototype.dispose=function(){this._binPack=null,this._mosaicRects={};for(var e=0,t=this._textures;e<t.length;e++){var i=t[e];i&&i.dispose()}this._textures.length=0},e}()}.apply(null,n))||(e.exports=r)},2187:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(2188),i(59),i(55),i(66)],void 0===(r=function(e,t,i,n,r,o){return function(){function e(){this._initialized=!1}return e.prototype.dispose=function(){this._program&&(this._program.dispose(),this._program=null),this._vertexArrayObject&&(this._vertexArrayObject.dispose(),this._vertexArrayObject=null)},e.prototype.render=function(e,t,i,n){e&&(this._initialized||this._initialize(e),e.setBlendFunctionSeparate(1,771,1,771),e.bindVAO(this._vertexArrayObject),e.bindProgram(this._program),t.setSamplingMode(i),e.bindTexture(t,0),this._program.setUniform1i("u_tex",0),this._program.setUniform1f("u_opacity",n),e.drawArrays(5,0,4),e.bindVAO())},e.prototype._initialize=function(e){if(this._initialized)return!0;var t=i.bitBlit.attributes,a=r.createProgram(e,i.bitBlit);if(!a)return!1;var s=new Int8Array(16);s[0]=-1,s[1]=-1,s[2]=0,s[3]=0,s[4]=1,s[5]=-1,s[6]=1,s[7]=0,s[8]=-1,s[9]=1,s[10]=0,s[11]=1,s[12]=1,s[13]=1,s[14]=1,s[15]=1;var l=new o(e,t,{geometry:[{name:"a_pos",count:2,type:5120,offset:0,stride:4,normalized:!1,divisor:0},{name:"a_tex",count:2,type:5120,offset:2,stride:4,normalized:!1,divisor:0}]},{geometry:n.createVertex(e,35044,s)});return this._program=a,this._vertexArrayObject=l,this._initialized=!0},e}()}.apply(null,n))||(e.exports=r)},2188:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(2189)],void 0===(r=function(e,t,i){Object.defineProperty(t,"__esModule",{value:!0}),t.bitBlit={name:"bitBlit",shaders:{vertexShader:i.resolveIncludes("bitBlit/bitBlit.vert"),fragmentShader:i.resolveIncludes("bitBlit/bitBlit.frag")},attributes:{a_pos:0,a_tex:1}}}.apply(null,n))||(e.exports=r)},2189:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(2190),i(585)],void 0===(r=function(e,t,i,n){Object.defineProperty(t,"__esModule",{value:!0});var r=new n(function(e){var t=i;return e.split("/").forEach(function(e){t&&(t=t[e])}),t});t.resolveIncludes=function(e){return r.resolveIncludes(e)}}.apply(null,n))||(e.exports=r)},2190:function(e,t,i){var n,r;n=[i.dj.c(e.i),t],void 0===(r=function(e,t){return{background:{"background.frag":"uniform lowp vec4 u_color;\nvoid main() {\n  gl_FragColor = u_color;\n}\n","background.vert":"attribute vec2 a_pos;\n\nuniform highp mat3 u_dvsMat3;\nuniform mediump float u_coord_range;\nuniform mediump float u_depth;\n\nvoid main() {\n  vec3 v_pos = u_dvsMat3 * vec3(u_coord_range * a_pos, 1.0);\n  gl_Position = vec4(v_pos.xy, 0.0, 1.0);\n}\n"},bitBlit:{"bitBlit.frag":"uniform lowp sampler2D u_tex;\nuniform lowp float u_opacity;\n\nvarying mediump vec2 v_uv;\n\nvoid main() {\n  lowp vec4 color = texture2D(u_tex, v_uv);\n\n  // Note: output in pre-multiplied alpha for correct alpha compositing\n  gl_FragColor = color *  u_opacity;\n}\n","bitBlit.vert":"attribute vec2 a_pos;\nattribute vec2 a_tex;\n\nvarying mediump vec2 v_uv;\n\nvoid main(void) {\n  gl_Position = vec4(a_pos, 0.0, 1.0);\n  v_uv = a_tex;\n}\n"},highlight:{"blur.frag":"// A gaussian blur shader. It blurs the alpha channel of its input\n// according to 4 different sigma and stores the results into the\n// four channel of the target framebuffer.\n\n// It is intended to be called twice; the first time to perform an\n// horizontal blur, and a second time to perform a vertical blur.\n\n// This shader is used to turn the highlight mask into a highlight\n// map. The highlight map is an approximation of the signed distance\n// field of the mask.\n\n\n// Interpolated texture coordinates.\nvarying mediump vec2 v_texcoord;\n\n// Blur direction information. There are two possible\n// configurations that the host code can use.\n//  - [1, 0, 1/WIDTH, 0] Used when blurring horizontally. In this\n//    case u_direction[0] = 1 is expressed in pixel and is fed to\n//    the gauss function to produce the value of the gaussian weight\n//    for that pixel, while u_direction[2] = 1/WIDTH is in texel units\n//    and is used to sample the right texel from the texture map.\n//  - [0, 1, 0, 1/HEIGHT] Used when blurring vertically. In this\n//    case u_direction[1] = 1 is expressed in pixel and is fed to\n//    the gauss function to produce the value of the gaussian weight\n//    for that pixel, while u_direction[3] = 1/HEIGHT is in texel units\n//    and is used to sample the right texel from the texture map.\nuniform mediump vec4 u_direction;\n\n// Source to destination channel selection matrix.\nuniform mediump mat4 u_channelSelector;\n\n// The highlight map is obtained by blurring the alpha channel of the highlight\n// mask accroding to these 4 values of the gaussian's sigma parameter.\nuniform mediump vec4 u_sigmas;\n\n// This is the highlight mask if we have not blurred horizontally yet, otherwise\n// it is the horizontally blurred highlight map and blurring it one more time\n// vertically will complete the process.\nuniform sampler2D u_texture;\n\n// The gaussian kernel. Note that it lacks the normalization constant, because\n// we want to store it unnormalized in the highlight map (i.e. having a peak\n// value of 1). Note also that we are using the SIMD (single instruction, multiple\n// data) capabilities of the GPU to compute four different gaussian kernels, one\n// for each sigma.\nmediump vec4 gauss4(mediump vec2 dir) {\n  return exp(-dot(dir, dir) / (2.0 * u_sigmas * u_sigmas));\n}\n\n// Same as above but uses only channel 3, aka `w`, aka `q`, aka `a`.\nmediump float gauss1(mediump vec2 dir) {\n  return exp(-dot(dir, dir) / (2.0 * u_sigmas[3] * u_sigmas[3]));\n}\n\nmediump vec4 selectChannel(mediump vec4 sample) {\n  return u_channelSelector * sample;\n}\n\n// Sample the input texture and accumulated its gaussian weighted value and the\n// total weight; operates on all four channels.\nvoid accumGauss4(mediump float i, inout mediump vec4 tot, inout mediump vec4 weight) {\n  // Computes the gaussian weights, one for each sigma.\n  // Note that u_direction.xy is [1, 0] when blurring horizontally and [0, 1] when blurring vertically.\n  mediump vec4 w = gauss4(i * u_direction.xy);\n\n  // Accumumates the values.\n  // Note that u_direction.xy is [1/WIDTH, 0] when blurring horizontally and [0, 1/HEIGHT] when blurring vertically.\n  tot += selectChannel(texture2D(u_texture, v_texcoord + i * u_direction.zw)) * w;\n\n  // Accumulates the weights.\n  weight += w;\n}\n\n// Sample the input texture and accumulated its gaussian weighted value and the\n// total weight; operates on a single channel.\nvoid accumGauss1(mediump float i, inout mediump float tot, inout mediump float weight) {\n  // Computes the gaussian weights, using only the last sigma.\n  // Note that u_direction.xy is [1, 0] when blurring horizontally and [0, 1] when blurring vertically.\n  mediump float w = gauss1(i * u_direction.xy);\n\n  // Accumumates the values.\n  // Note that u_direction.xy is [1/WIDTH, 0] when blurring horizontally and [0, 1/HEIGHT] when blurring vertically.\n  tot += selectChannel(texture2D(u_texture, v_texcoord + i * u_direction.zw))[3] * w;\n\n  // Accumulates the weights.\n  weight += w;\n}\n\nvoid main(void) {\n  // Initialize accumulated values and weights to zero.\n  mediump float tot = 0.0;\n  mediump float weight = 0.0;\n\n  // Accumulates enough samples. These will be taken\n  // horizontally or vertically depending on the value\n  // of u_direction.\n  accumGauss1(-4.0, tot, weight);\n  accumGauss1(-3.0, tot, weight);\n  accumGauss1(-2.0, tot, weight);\n  accumGauss1(-1.0, tot, weight);\n  accumGauss1(0.0, tot, weight);\n  accumGauss1(1.0, tot, weight);\n  accumGauss1(2.0, tot, weight);\n  accumGauss1(3.0, tot, weight);\n  accumGauss1(4.0, tot, weight);\n\n  // Originally we were performing 4 blurs in parallel;\n  // Now we store the only result in the alpha component.\n  // dari8942: In theory we could disable writing to rgb\n  // using a color mask but I don't really feel like messing\n  // with that now.\n  gl_FragColor = vec4(0.0, 0.0, 0.0, tot / weight);\n}\n","highlight.frag":"// Takes as input the highlight map, estimated the signed distance field,\n// and shades the fragments according to their estimated distance from the\n// edge of the highlighted feature.\n\n// A shade texture is used to turn distance values into colors; the shade\n// texture is basically a color gradient and is recomputed on the host\n// every time that the user alters the highlight options.\n\n// Interpolated texture coordinates.\nvarying mediump vec2 v_texcoord;\n\n// The highlight map. Each channel is a blurred\n// version of the alpha channel of the highlight mask.\n//  - Channel 0 (red) corresponds to a gaussian blur with sigma = u_sigmas[0];\n//  - Channel 1 (green) corresponds to a gaussian blur with sigma = u_sigmas[1];\n//  - Channel 2 (blue) corresponds to a gaussian blur with sigma = u_sigmas[2];\n//  - Channel 3 (alpha) corresponds to a gaussian blur with sigma = u_sigmas[3];\n// As of today, only channel 3 is used for distance estimation.\n// But the availability of different amounts of blur leaves the\n// door open to multi-scale approaches.\nuniform sampler2D u_texture;\n\n// The highlight map was obtained by blurring the alpha channel of the highlight\n// mask accroding to these 4 values of the gaussian's sigma parameter.\nuniform mediump vec4 u_sigmas;\n\n// A 1-D texture used to shade the highlight.\nuniform sampler2D u_shade;\n\n// The 1-D shade texture is spreaded between u_minMaxDistance[0] and u_minMaxDistance[1].\nuniform mediump vec2 u_minMaxDistance;\n\n// Signed distance estimation.\nmediump float estimateDistance() {\n  // Use the largest sigma and the corresponding distance value stored in the\n  // last channel of the highlight map.\n  mediump float sigma = u_sigmas[3];\n  mediump float y = texture2D(u_texture, v_texcoord)[3];\n\n  // Estimates the distance by linearization and local inversion around\n  // the inflection point. The inflection point is in x = 0.\n  const mediump float y0 = 0.5;                           // Value of the convolution at the inflection point.\n  mediump float m0 = 1.0 / (sqrt(2.0 * 3.1415) * sigma);  // Slope of the convolution at the inflection point.\n  mediump float d = (y - y0) / m0;                        // Inversion of a local linearization.\n\n  // Return the estimated distance.\n  return d;\n}\n\n// Shading based on estimated distance.\nmediump vec4 shade(mediump float d) {\n  // Maps the sampled distance from the [A, D] range (see HighlightRenderer::setHighlightOptions) to [0, 1].\n  mediump float mappedDistance = (d - u_minMaxDistance.x) / (u_minMaxDistance.y - u_minMaxDistance.x);\n\n  // Force to [0, 1]; it should not be necessary because the shade texture uses the CLAMP address mode, so\n  // this should happen anyway internally to the sampler, but in practice it is needed to avoid weird\n  // banding artifacts.\n  // We don't really know if we need this or not.\n  mappedDistance = clamp(mappedDistance, 0.0, 1.0);\n\n  // Sample the 1-D shade texture on its center line (i.e. on t=0.5).\n  return texture2D(u_shade, vec2(mappedDistance, 0.5));\n}\n\nvoid main(void) {\n  // Estimate the distance.\n  mediump float d = estimateDistance();\n\n  // Shade the distance.\n  gl_FragColor = shade(d);\n}\n","textured.vert":"// Identity vertex shader that outputs an untransformed 2-D vertex\n// and passes its texture coordinates unchanged to the interpolator.\n\n// Vertex position.\nattribute mediump vec2 a_position;\n\n// Texture coordinates.\nattribute mediump vec2 a_texcoord;\n\n// Texture coordinates to be interpolated.\nvarying mediump vec2 v_texcoord;\n\nvoid main(void) {\n  // Pass the position unchanged.\n  gl_Position = vec4(a_position, 0.0, 1.0);\n\n  // Pass the texture coordinates unchanged.\n  v_texcoord = a_texcoord;\n}\n"},magnifier:{"magnifier.frag":"uniform lowp vec4 u_background;\nuniform mediump sampler2D u_readbackTexture;\nuniform mediump sampler2D u_maskTexture;\nuniform mediump sampler2D u_overlyTexture;\n\nvarying mediump vec2 v_texCoord;\n\nvoid main(void)\n{\n  lowp vec4 color = texture2D(u_readbackTexture, v_texCoord);\n  color = color + (1.0 - color.a) * u_background;\n\n  // calculate the grayscale value of the mask:\n  lowp vec4 mask_color = texture2D(u_maskTexture, v_texCoord);\n  lowp float gray = 1.0 - dot(mask_color, vec4(0.3, 0.59, 0.11, 0));\n  // make all the map color outside the mask black\n  color *= gray;\n\n  lowp vec4 overley_color = texture2D(u_overlyTexture, v_texCoord);\n\n  // premultiply the overlay color\n  overley_color.rgb *= overley_color.a;\n  gl_FragColor = overley_color + (1.0 - overley_color.a) * color;\n}\n","magnifier.vert":"precision mediump float;\n\nattribute mediump vec2 a_pos; // encoded values are 0 and 1\n\nuniform mediump vec2 u_drawPos; // the center position of the magnifier\nuniform mediump float u_width; // the width of the magnifier in normalized display coords\nuniform mediump float u_height; // the height of the magnifier in normalized display coords\n\nvarying mediump vec2 v_texCoord;\n\n\nvoid main(void)\n{\n  v_texCoord = a_pos;\n  vec2 coord = u_drawPos + vec2(a_pos - 0.5) * vec2(u_width, u_height);\n  gl_Position = vec4(coord, 0.0, 1.0);\n}\n"},materials:{"constants.glsl":"const float C_DEG_TO_RAD = 3.14159265359 / 180.0;\nconst float SIGNED_BYTE_TO_UNSIGNED = 128.0;\n\n// markers\nconst float SOFT_EDGE_RATIO = 1.0; // use blur here if needed\n\n// lines\nconst float THIN_LINE_WIDTH_FACTOR = 1.1;\n\n// meaning that a 2 pixels line width is considered a thin line\nconst float THIN_LINE_HALF_WIDTH = 1.0;\n\n// labels \nconst float OFFSET_PRECISION = 1.0 / 8.0;\nconst float OUTLINE_SCALE = 1.0 / 5.0;\nconst float SDF_FONT_SIZE = 24.0;\n\n// maximum SDF distance of 8 pixels represent the distance values that range from -2 inside the\n// geometry to 6 on the outside. 6 is actually the maximum distance outside the glyph, therefore\n// it is the limitation of the halo which is 1/4 of the geometry size.\nconst float MAX_SDF_DISTANCE = 8.0;\n\nconst float PLACEMENT_PADDING = 8.0;\n\n\nconst float EPSILON = 0.0000001; \n\nconst int MAX_FILTER_COUNT = 2;\n","effects.glsl":"\nuniform mat4 u_insideEffectMat4[ MAX_FILTER_COUNT ];\nuniform mat4 u_outsideEffectMat4[ MAX_FILTER_COUNT ];\n\nvec4 getEffectColor(in vec4 color, in float filterFlags) {\n  vec4 outColor = vec4(color);\n\n  // default visibility filter is index 0, index 1+ are effects\n  for (int i = 1; i < EFFECT_COUNT + 1; i++) {\n    float bit = getBit(filterFlags, i);\n    \n    outColor = u_insideEffectMat4[ i ] * (bit  * outColor) + u_outsideEffectMat4[ i ] * ((1.0 - bit) * outColor);\n  }\n  \n  return outColor; \n}\n\nvoid applyFilter(inout vec4 color, inout vec3 pos, in float filterFlags) {\n\n  // default visibility filter is index 0, index 1+ are effects\n  for (int i = 0; i < EFFECT_COUNT + 1; i++) {\n    float bit = getBit(filterFlags, i); \n\n    color = u_insideEffectMat4[ i ] * (bit  * color) + u_outsideEffectMat4[ i ] * ((1.0 - bit) * color);\n  }\n\n  // If we are not visible, clip the vertex if we are doing a hit-test\n  pos.z += 2.0 * (1.0 - getBit(filterFlags, 0)); \n}\n\nvoid applyFilterLabels(inout vec4 color, inout vec3 pos, in float filterFlags) {\n  float bit = getBit(filterFlags, 0); \n\n  pos.z += 2.0 * (1.0 - bit);\n\n  // When outsideLabelsVisible is false, we also clip labels if they fail any effect filter\n#ifndef OUTSIDE_LABELS_VISIBLE\n  for (int i = 1; i < EFFECT_COUNT + 1; i++) {\n    float bit = getBit(filterFlags, i); \n\n    pos.z += 2.0 * (1.0 - bit);\n  }\n#endif\n}\n",fill:{"fill.frag":"precision highp float;\n\n#include <materials/constants.glsl>\n\n#ifdef ID\n\nvarying highp vec4 v_id;\n\n#endif // ID\n\n#ifdef PATTERN\n\nuniform lowp sampler2D u_texture;\n\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_tileTextureCoord;\n\n#endif // PATTERN\n\n#ifdef DOT_DENSITY\n\nuniform mediump mat4 u_dotColors[ 2 ];\nuniform sampler2D u_dotTextures[ 2 ];\nuniform vec4 u_dotBackgroundColor;\n\nvarying highp vec4 v_dotThresholds[ 2 ];\nvarying vec2 v_dotTextureCoords;\n\n#endif\n\nvarying lowp vec4 v_color;\nvarying lowp float v_opacity;\n\nfloat max4(vec4 target) {\n  return max(max(max(target.x, target.y), target.z), target.w);\n}\n\nvoid main() {\n\n#ifdef ID\n\n  gl_FragColor = v_id;\n\n#elif defined(PATTERN)\n\n  // normalize the calculated texture coordinate such that it fits in the range of 0 to 1.\n  mediump vec2 normalizedTextureCoord = mod(v_tileTextureCoord, 1.0);\n  // interpolate the image coordinate between the top-left and the bottom right to get the actual position to sample.\n  // after normalizing the position, we get a value ranging between 0 and 1 which refers to the entire texture, however\n  // we need to only sample from area that has our sprite in the mosaic.\n  mediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\n  // sample the sprite mosaic\n  lowp vec4 color = texture2D(u_texture, samplePos);\n  gl_FragColor = v_opacity * v_color * color;\n\n#elif defined(DOT_DENSITY) && !defined(HIGHLIGHT)\n\n  vec4 textureThresholds0 = texture2D(u_dotTextures[0], v_dotTextureCoords);\n  vec4 textureThresholds1 = texture2D(u_dotTextures[1], v_dotTextureCoords);\n\n  vec4 difference0 = v_dotThresholds[0] - textureThresholds0;\n  vec4 difference1 = v_dotThresholds[1] - textureThresholds1;\n\n#ifdef DD_DOT_BLENDING\n\n  vec4 isPositive0 = step(0.0, difference0);\n  vec4 isPositive1 = step(0.0, difference1);\n\n  float weightSum = dot(isPositive0, difference0) + dot(isPositive1, difference1);\n  float lessThanEqZero = step(weightSum, 0.0);\n  float greaterThanZero = 1.0 - lessThanEqZero ;\n  float divisor = (weightSum + lessThanEqZero); // Guard against divide by zero\n\n  vec4 weights0 = difference0 * isPositive0 / divisor;\n  vec4 weights1 = difference1 * isPositive1 / divisor;\n\n  vec4 dotColor = u_dotColors[0] * weights0 + u_dotColors[1] * weights1;\n\n  gl_FragColor = greaterThanZero * dotColor + lessThanEqZero * u_dotBackgroundColor;\n\n#else\n\n  float diffMax = max(max4(difference0), max4(difference1));\n  float lessThanZero = step(diffMax, 0.0);\n  float greaterOrEqZero = 1.0 - lessThanZero;\n\n  vec4 isMax0 = step(diffMax, difference0);\n  vec4 isMax1 = step(diffMax, difference1);\n\n  vec4 dotColor = u_dotColors[0] * isMax0 + u_dotColors[1] * isMax1;\n\n  gl_FragColor = greaterOrEqZero * dotColor + lessThanZero * u_dotBackgroundColor;\n\n#endif\n\n#else\n\n  gl_FragColor = v_opacity * v_color;\n\n#endif // PATTERN\n\n#ifdef HIGHLIGHT\n\n  gl_FragColor.a = 1.0;\n\n#endif // HIGHLIGHT\n}\n","fill.vert":"precision mediump float;\n\n#include <materials/constants.glsl>\n#include <materials/utils.glsl>\n#include <materials/vv.glsl>\n#include <materials/effects.glsl>\n\nattribute vec2 a_pos;\nattribute vec4 a_id;                // objectId in RGBA components\nattribute float  a_visible;         // one byte controlling the visibility of the vertex (separate buffer),\n\n#ifndef DOT_DENSITY\nattribute vec4 a_color;\nattribute vec4 a_tlbr;\nattribute vec4 a_aux1;\nattribute vec2 a_aux2;\nattribute vec4 a_aux3;              // encodes a bitset (CIM) detailing vv locking\n#endif\n\n#if defined(VV_COLOR) || defined(VV_OPACITY)\nattribute highp vec4 a_vv;\n#endif\n\nuniform highp mat3 u_dvsMat3;      // premultiplies DisplayMat3 * ViewMat3 * ScreenMat3\nuniform highp float u_pixelRatio;\n\nvarying lowp vec4 v_color;\nvarying lowp float v_opacity;\n\n#ifdef ID\nvarying highp vec4 v_id;\n#endif\n\n#ifdef PATTERN\nuniform mediump float u_zoomFactor;\nuniform mediump vec2 u_mosaicSize;\n\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_tileTextureCoord;\n#endif\n\n#ifdef DOT_DENSITY\nattribute highp vec4 a_dd1;\nattribute highp vec4 a_dd2;\n\nuniform float u_dotValue;\nuniform float u_tileDotsOverArea; \n\nuniform float u_dotTextureDotCount;\nuniform float u_tileZoomFactor; \n\nvarying vec4 v_dotThresholds[ 2 ]; \nvarying vec2 v_dotTextureCoords;\n\nvec4 dotThreshold(vec4 featureAttrOverFeatureArea, float dotValue, float tileDotsOverArea) {\n  return featureAttrOverFeatureArea * (1.0 / dotValue)  * (1.0 / tileDotsOverArea);\n}\n#endif\n\nvoid main()\n{\n// Arguably DotDensity should be extracted to its own shader. This gets a bit\n// fungly because DD uses a signifcantly different stride\n#ifndef DOT_DENSITY \n  float a_bitset = a_aux3.w; \n  float isColorLocked = getBit(a_bitset, 0);\n  \n  v_color = a_color;\n#else\n  v_color = vec4(0.0, 0.0, 0.0, 1.0);    // for highlight\n#endif\n  v_opacity = 1.0;\n  \n#ifdef ID\n  v_id = a_id;\n#endif\n  \n#ifdef VV_OPACITY\n  v_opacity = getVVOpacity(a_vv.y);\n#endif\n  \n#ifdef VV_COLOR\n  v_color = getVVColor(a_vv.x, v_color, isColorLocked);\n#endif\n  \n#ifdef PATTERN\n  vec2 aux2 = (1.0 / SIGNED_BYTE_TO_UNSIGNED) * a_aux2;\n  vec2 symbolOffset = u_zoomFactor * (a_aux1.zw - SIGNED_BYTE_TO_UNSIGNED);\n  mat3 patternMatrix = mat3(1.0);\n\n  // calculate the pattern matrix\n  patternMatrix[0][0] = 1.0 / (u_zoomFactor * a_aux1.x * aux2.x);\n  patternMatrix[1][1] = 1.0 / (u_zoomFactor * a_aux1.y * aux2.y);\n\n  // calculate the texture coordinates of the current vertex. It will of course get interpolated.\n  // The pattern matrix is a 3x3 scale matrix which 'tiles' the texture inside the tile, translating from\n  // tile coordinates to texture coordinates.\n  v_tileTextureCoord = (patternMatrix * vec3(a_pos + symbolOffset, 1.0)).xy;\n  v_tlbr = a_tlbr / u_mosaicSize.xyxy;\n\n#elif defined(DOT_DENSITY)\n  float size = u_tileZoomFactor * 512.0 * 1.0 / u_pixelRatio;\n\n  v_dotThresholds[0] = dotThreshold(a_dd1, u_dotValue, u_tileDotsOverArea);\n  v_dotThresholds[1] = dotThreshold(a_dd2, u_dotValue, u_tileDotsOverArea);\n  v_dotTextureCoords = (a_pos + 0.5) / size;\n\n#endif\n  vec3 v_pos = u_dvsMat3 * vec3(a_pos, 1.);\n\n  applyFilter(v_color, v_pos, a_visible);\n  \n  gl_Position = vec4(v_pos, 1.0);\n}\n"},icon:{"icon.frag":"precision mediump float;\n\n#include <materials/constants.glsl>\n#include <materials/utils.glsl>\n#include <util/encoding.glsl>\n#include <materials/effects.glsl>\n#include <materials/constants.glsl>\n\nuniform lowp sampler2D u_texture;\n\nvarying lowp vec2 v_tex;\nvarying lowp float v_transparency;\nvarying mediump vec2 v_size;\nvarying lowp vec4 v_color;\nvarying float v_visible;\n\n#ifdef SDF\nvarying lowp vec4 v_outlineColor;\nvarying mediump float v_outlineWidth;\nvarying float v_overridingOutlineColor;\n#endif // SDF\n\n#ifdef HIGHLIGHT\nvarying float v_isThinGeometry;\n#endif // HIGHLIGHT\n\n#ifdef ID\nvarying highp vec4 v_id;\n#endif // ID\n\nvoid main()\n{\n#ifdef SDF\n  lowp vec4 fillPixelColor = v_color;\n\n  // calculate the distance from the edge [-0.5, 0.5]\n  float d = 0.5 - rgba2float(texture2D(u_texture, v_tex));\n\n  // the soft edge ratio is about 1.5 pixels allocated for the soft edge.\n  float size = max(v_size.x, v_size.y);\n  float dist = d * size * SOFT_EDGE_RATIO;\n\n  // set the fragment's transparency according to the distance from the edge\n  fillPixelColor *= clamp(0.5 - dist, 0.0, 1.0);\n\n  float outlineWidth = v_outlineWidth;\n\n  #ifdef HIGHLIGHT\n    outlineWidth = max(outlineWidth, 4.0 * v_isThinGeometry);\n  #endif\n\n  // count for the outline\n  // therefore tint the entire icon area.\n  if (outlineWidth > 0.25) {\n    lowp vec4 outlinePixelColor = v_overridingOutlineColor * v_color + (1.0 - v_overridingOutlineColor) * v_outlineColor;\n\n    // outlines can't be larger than the size of the symbol\n    float clampedOutlineSize = min(outlineWidth, size);\n\n    outlinePixelColor *= clamp(0.5 - abs(dist) + clampedOutlineSize * 0.5, 0.0, 1.0);\n\n    // finally combine the outline and the fill colors (outline draws on top of fill)\n    gl_FragColor = v_transparency * ((1.0 - outlinePixelColor.a) * fillPixelColor + outlinePixelColor);\n  }\n  else {\n    gl_FragColor = v_transparency * fillPixelColor;\n  }\n#else // not an SDF\n   lowp vec4 texColor = texture2D(u_texture, v_tex);\n   gl_FragColor = v_transparency * getEffectColor(texColor, v_visible);\n#endif // SDF\n\n#ifdef HIGHLIGHT\n  gl_FragColor.a = step(1.0 / 255.0, gl_FragColor.a);\n#endif // HIGHLIGHT\n\n#ifdef ID\n  if (gl_FragColor.a < 1.0 / 255.0) {\n    discard;\n  }\n  gl_FragColor = v_id;\n#endif // ID\n}\n","icon.vert":"precision mediump float;\n\n#include <materials/constants.glsl>\n#include <materials/utils.glsl>\n#include <materials/vv.glsl>\n#include <materials/effects.glsl>\n\nattribute vec2 a_pos;\nattribute vec4 a_vertexOffsetAndTex;\nattribute vec4 a_id;                   // objectId in RGBA components\nattribute vec4 a_color;\nattribute vec4 a_outlineColor;\nattribute vec4 a_sizeAndOutlineWidth;\nattribute float a_visible;             // one byte controlling the vertex visibility (separate buffer)\n\n#ifdef VV\nattribute highp vec4 a_vv;\n#endif\n\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform vec2 u_mosaicSize;            // mosaic size in pixels\n\nvarying lowp vec4 v_color;\nvarying mediump vec2 v_tex;           // texture coordinates used to sample the sprite atlas\nvarying lowp float v_transparency;    // the calculated transparency to be applied by the fragment shader.\nvarying mediump vec2 v_size;          // icon size in px\nvarying float v_visible;\n\n#ifdef SDF\nvarying lowp vec4 v_outlineColor;\nvarying mediump float v_outlineWidth;\nvarying float v_overridingOutlineColor;\n#endif\n\n#ifdef HIGHLIGHT\nvarying float v_isThinGeometry;\n#endif // HIGHLIGHT\n\n#ifdef ID\nvarying highp vec4 v_id;\n#endif\n\nvec2 getMarkerSize(inout vec2 offset, in vec2 baseSize, in float vvSize) {\n  float f = getVVSize(baseSize.y, vvSize);\n  vec2 size = vec2(f * baseSize.x / baseSize.y, f);\n\n  offset *= (size / baseSize);\n  return size;\n}\n\nvoid main()\n{\n  vec2 offset = a_vertexOffsetAndTex.xy;\n  vec2 a_tex = a_vertexOffsetAndTex.zw + SIGNED_BYTE_TO_UNSIGNED;\n  vec2 a_size = a_sizeAndOutlineWidth.xy;\n  float a_bitset = a_sizeAndOutlineWidth.w;\n\n  float isMapAligned = getBit(a_bitset, 0);\n  float isColorLocked = getBit(a_bitset, 1);\n  float isThinGeometry = getBit(a_bitset, 2);\n  mat3 offsetMat3 = isMapAligned * u_displayViewMat3 + (1.0 - isMapAligned) * u_displayMat3;\n\n  v_transparency = 1.0;\n  v_color = a_color;\n  v_size = a_size;\n  v_tex = a_tex / u_mosaicSize; // texture coords and transparency\n  v_visible = a_visible;\n\n#ifdef ID\n  v_id = a_id;\n#endif\n\n#ifdef VV_OPACITY\n  v_transparency = getVVOpacity(a_vv.z);\n#endif\n\n#ifdef VV_COLOR\n  v_color = getVVColor(a_vv.y, a_color, isColorLocked);\n#endif // VV_COLOR\n\n#ifdef VV_SIZE\n  v_size = getMarkerSize(offset, a_size, a_vv.x);\n#endif\n\n#ifdef VV_ROTATION\n  offset = (getVVRotationMat3(a_vv.w) * vec3(offset, 0.0)).xy;\n#endif\n\n#ifdef SDF\n  #ifdef VV_COLOR\n    // this is true only if we have SDF and color VV\n    v_overridingOutlineColor = isThinGeometry;\n  #else\n    v_overridingOutlineColor = 0.0;\n  #endif\n\n  offset *= 2.0;\n  v_outlineColor = getEffectColor(a_outlineColor, a_visible);\n  // YF: in practice v_size.x and v_size.y are identical since we're mostly dealing with sms\n  v_outlineWidth = min(a_sizeAndOutlineWidth.z, max(v_size.x - 0.99, 0.0));\n#endif\n\n#ifdef HIGHLIGHT\n  v_isThinGeometry = isThinGeometry;\n#endif\n\n  vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + offsetMat3 * vec3(offset, 0.0);\n\n  applyFilter(v_color, pos, a_visible);\n\n  gl_Position = vec4(pos, 1.0);\n}\n"},label:{"label.frag":"precision lowp float;\n\nuniform mediump sampler2D u_referenceTex;\nuniform mediump vec2 u_screenSize;\nuniform mediump float u_pixelRatio;\n\nvarying mediump float v_antialiasingWidth;\nvarying mediump float v_edgeDistanceOffset;\nvarying mediump vec2 v_tex;\n\n#ifdef ID\nvarying mediump float v_fadeStep;\n#else\nuniform lowp sampler2D u_texture;\nvarying mediump vec4 v_color;\n#endif // ID\n\nconst vec3 epsilon = vec3(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);\n\nvoid main()\n{\n  mediump vec2 refTextPos = gl_FragCoord.xy / (u_pixelRatio * u_screenSize.xy);\n  mediump vec4 referenceFragment = texture2D(u_referenceTex, refTextPos);\n#ifdef ID\n  mediump float alpha = clamp(referenceFragment.a + v_fadeStep, 0.0, 1.0);\n  // fill the whole quad\n  gl_FragColor = vec4(alpha);\n#else\n  // read the fade alpha\n  lowp float fadeAlpha = referenceFragment.a;\n\n  // read the distance from the SDF texture\n  lowp float dist = texture2D(u_texture, v_tex).a;\n\n  // the edge distance if a factor of the outline width\n  // We cap this to 0.25 to prevent this from becomming negative / running into the glyph boundaries\n  float glyphEdgeDistance = max(0.75 - v_edgeDistanceOffset, 0.25);\n\n  // use a smooth-step in order to calculate the geometry of the shape given by the distance field\n  lowp float sdfAlpha = smoothstep(glyphEdgeDistance - v_antialiasingWidth, glyphEdgeDistance + v_antialiasingWidth, dist);\n\n  gl_FragColor = fadeAlpha * sdfAlpha * v_color;\n#endif\n}\n","label.vert":"precision mediump float;\n\n#include <materials/constants.glsl>\n#include <materials/utils.glsl>\n#include <materials/vv.glsl>\n#include <materials/effects.glsl>\n\nattribute vec2 a_pos;                         // (2 x i16)\nattribute vec4 a_color;                       // (4 x u8)\nattribute vec2 a_vertexOffset;                // (2 x i16) offset from the anchor point of the string\nattribute vec4 a_texAndSize;                  // (4 x u8) texture coordinatesm and font size. w is for the halo size\nattribute vec4 a_refSymbolAndPlacementOffset; // (4 x u8) reference symbol offset (px) and the placement offset (px)\nattribute float a_vvSize;                     // size visual variable\nattribute lowp float  a_visible;              // a one byte controlling the visibility of the vertex (separate buffer)\nattribute mediump vec2 a_visibilityRange;     // (2 x u8);\n\nuniform mediump float u_zoomLevel;            // the current zoom level X 10\nuniform highp mat3 u_dvsMat3;                 // premultiplies displayMat3 * viewMat3 * screenMat3\nuniform highp mat3 u_displayMat3;\nuniform float u_mapRotation;\nuniform float u_mapAligned;\nuniform vec2 u_mosaicSize;\nuniform float u_pixelRatio;\n\nvarying mediump float v_antialiasingWidth;\nvarying mediump float v_edgeDistanceOffset;\nvarying mediump vec2 v_tex;                   // texture coordinates used to sample the glyph atlas\nvarying mediump vec4 v_color;\n\n#ifdef ID                                     // somewhat of a misnomer - id is used here for the label alpha phase\nuniform mediump float u_fadeStep; \nvarying mediump float v_fadeStep;\n#endif\n\nfloat getZ(in float minZoom, in float maxZoom, in float angle) {\n  float glyphAngle = angle * 360.0 / 254.0;\n  float mapAngle = u_mapRotation * 360.0 / 254.0;\n  float diffAngle = min(360.0 - abs(mapAngle - glyphAngle), abs(mapAngle - glyphAngle));\n  float z = 0.0;\n\n  // make sure range is inclusive\n  z += 2.0 * (1.0 - step(minZoom, u_zoomLevel));\n  z += 2.0 * (1.0 - step(u_zoomLevel, maxZoom));\n  z += 2.0 * u_mapAligned * step(90.0, diffAngle);\n  return z;\n}\n\nvoid main()\n{\n  float isHalo = mod(a_pos, 2.0).x; // lsb of a_pos denotes whether a vertex is part of the halo or not\n  vec3 pos = vec3(floor(a_pos * 0.5), 1.0);\n  vec2 placementDir = a_refSymbolAndPlacementOffset.zw - 1.0;  // encoded as dir + 1.0\n  vec2 vertexOffset = a_vertexOffset * OFFSET_PRECISION;\n  float refSymbolSize = a_refSymbolAndPlacementOffset.y;\n  float fontSize = a_texAndSize.z;\n  float z = getZ(a_visibilityRange.x, a_visibilityRange.y, a_refSymbolAndPlacementOffset.x);\n\n  float fontScale = fontSize / SDF_FONT_SIZE;\n  float halfSize = refSymbolSize / 2.0;\n\n  v_color = a_color;\n  v_tex = a_texAndSize.xy / u_mosaicSize;\n\n#ifdef ID\n  v_fadeStep = u_fadeStep;\n#endif\n  \n#ifdef VV_SIZE // unlike with text, this is the VV_SIZE of the reference symbol, not the label itself\n  halfSize = getVVSize(refSymbolSize, a_vvSize) / 2.0;\n#endif\n  // if halo.x is zero (not a halo) v_edgeDistanceOffset will end up being zero as well.\n  v_edgeDistanceOffset = isHalo * OUTLINE_SCALE * a_texAndSize.w / fontScale / MAX_SDF_DISTANCE;\n  v_antialiasingWidth = 0.106 * SDF_FONT_SIZE / fontSize / u_pixelRatio;\n\n  vec2 placementOffset = placementDir * (halfSize + PLACEMENT_PADDING);\n  vec3 glyphOffset = u_displayMat3 * vec3(vertexOffset + placementOffset, 0.0);\n  vec3 v_pos = u_dvsMat3 * pos + glyphOffset;\n  \n  applyFilterLabels(v_color, v_pos, a_visible);\n\n#ifdef DEBUG\n  v_color = vec4(a_color.rgb, z == 0.0 ? 1.0 : 0.645);  // visualize hidden glyphs\n#endif\n  \n  gl_Position = vec4(v_pos.xy, v_pos.z + z, 1.0);\n}\n"},line:{"line.frag":"precision lowp float;\n\n#include <util/encoding.glsl>\n#include <materials/constants.glsl>\n\nuniform lowp float u_blur;\nuniform mediump float u_antialiasing;\n\nvarying mediump vec2 v_normal;\nvarying mediump float v_lineHalfWidth;\nvarying lowp vec4 v_color;\nvarying lowp float v_transparency;\n\n#if defined(PATTERN) || defined(SDF)\nuniform sampler2D u_texture;\nuniform mediump float u_zoomFactor;\n\nvarying mediump vec4 v_tlbr; // normalized pattern coordinates [0, 1]\nvarying mediump vec2 v_patternSize;\nvarying highp float v_accumulatedDistance;\n#endif // PATTERN SDF\n\n#ifdef SDF\nconst float sdfPatternHalfWidth = 15.5; // YF: assumed that the width will be set to 31\nconst float widthFactor = 2.0;\n#endif // SDF\n\n#ifdef ID\nvarying highp vec4 v_id;\n#endif // ID\n\n\nvoid main()\n{\n  // for now assume that a thin line is a line which is under 2 pixels (1 pixels on either sides of the centerline)\n  mediump float thinLineFactor = max(THIN_LINE_WIDTH_FACTOR * step(v_lineHalfWidth, THIN_LINE_HALF_WIDTH), 1.0);\n\n  // dist represent the distance of the fragment from the line. 1.0 or -1.0 will be the values on the edge of the line,\n  // and any value in between will be inside the line (the sign represent the direction - right or left).\n  // since u_linewidth.s (half line width) is represented in pixels, dist is also given in pixels\n  mediump float fragDist = length(v_normal) * v_lineHalfWidth;\n\n  // calculate the alpha given the difference between the line-width and the distance of the fragment from the center-line.\n  // when it is a thin line then use a slightly shallower slope in order to add more feathering\n  lowp float alpha = clamp(thinLineFactor * (v_lineHalfWidth - fragDist) / (u_blur + thinLineFactor - 1.0), 0.0, 1.0);\n\n#if defined(SDF) && !defined(HIGHLIGHT) // When we render the highlight, we want to treat the line as if it was solid\n  mediump float lineHalfWidth = widthFactor * v_lineHalfWidth;\n  mediump float lineWidthRatio = lineHalfWidth / sdfPatternHalfWidth;\n  mediump float relativeTexX = mod((u_zoomFactor * v_accumulatedDistance + v_normal.x * lineHalfWidth) / (lineWidthRatio * v_patternSize.x), 1.0);\n  mediump float relativeTexY = 0.5 + 0.5 * v_normal.y;\n\n  // claculate the actual texture coordinates by interpolating between the TL/BR pattern coordinates\n  mediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\n\n  // calculate the distance from the edge [-0.5, 0.5]\n  mediump float d = rgba2float(texture2D(u_texture, texCoord)) - 0.5;\n\n  // the distance is a proportional to the line width\n  float dist = d * lineHalfWidth;\n\n  lowp vec4 fillPixelColor = v_transparency * alpha * clamp(0.5 - dist, 0.0, 1.0) * v_color;\n  gl_FragColor = fillPixelColor;\n#elif defined(PATTERN) && !defined(HIGHLIGHT)  // When we render the highlight, we want to treat the line as if it was solid\n  // we need to calculate the relative portion of the line texture along the line given the accumulated distance along the line\n  // The computed value should is anumber btween 0 and 1 which will later be used to interpolate btween the BR and TL values\n  mediump float relativeTexX = mod((u_zoomFactor * v_accumulatedDistance + v_normal.x * v_lineHalfWidth) / v_patternSize.x, 1.0);\n\n  // in order to calculate the texture coordinates prependicular to the line (Y axis), we use the interpolated normal values\n  // which range from -1.0 to 1.0. On the line's centerline, the value of the interpolated normal is 0.0, however the relative\n  // texture value shpould be 0.5 (given that at the bottom of the line, the texture coordinate must be equal to 0.0)\n  // (TL) ---------------------------      --\x3e left edge of line. Interpolatedf normal is 1.0\n  //              | -> line-width / 2\n  //      - - - - - - - - - - - - - -\n  //              | -> line-width / 2\n  //      ---------------------------- (BR)--\x3e right edge of line. Interpolatedf normal is -1.0\n\n  mediump float relativeTexY = 0.5 + (v_normal.y * v_lineHalfWidth / v_patternSize.y);\n\n  // claculate the actual texture coordinates by interpolating between the TL/BR pattern coordinates\n  mediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\n\n  // get the color from the texture\n  lowp vec4 color = texture2D(u_texture, texCoord);\n\n  gl_FragColor = v_transparency * alpha * v_color * color;\n#else // solid line (no texture, no pattern)\n  // output the fragment color\n  gl_FragColor = v_transparency * alpha * v_color;\n#endif // SDF\n\n#ifdef HIGHLIGHT\n  gl_FragColor.a = step(1.0 / 255.0, gl_FragColor.a);\n#endif // HIGHLIGHT\n\n#ifdef ID\n  if (gl_FragColor.a < 1.0 / 255.0) {\n    discard;\n  }\n  gl_FragColor = v_id;\n#endif // ID\n}\n","line.vert":"precision mediump float;\n\n#include <materials/constants.glsl>\n#include <materials/utils.glsl>\n#include <materials/vv.glsl>\n#include <materials/effects.glsl>\n\nattribute vec2 a_pos;\nattribute vec4 a_id;\nattribute vec4 a_color;\nattribute vec4 a_offsetAndNormal;\nattribute vec2 a_accumulatedDistanceAndHalfWidth;\nattribute vec4 a_tlbr;\nattribute vec4 a_segmentDirection;\nattribute float  a_visible;                // a one byte controlling the visibility of the vertex (separate buffer)\n\n#ifdef VV\nattribute highp vec3 a_vv;\n#endif\n\nuniform highp mat3 u_dvsMat3;              // premultiplies DisplayMat3 * ViewMat3 * ScreenMat3\nuniform highp mat3 u_displayViewMat3;     // premultiplies DisplayMat3 * ViewMat3\nuniform mediump float u_zoomFactor;\nuniform mediump float u_antialiasing;\n\nvarying mediump vec2 v_normal;             // interpolated normal to the line. packed into the two LSBs of the vertex coordinate\nvarying mediump float v_lineHalfWidth;\nvarying lowp vec4 v_color;\nvarying lowp float v_transparency;\n\n#ifdef ID\nvarying highp vec4 v_id;\n#endif\n\n#ifdef PATTERN\nuniform mediump vec2 u_mosaicSize;\n\nvarying mediump vec4 v_tlbr;               // normalized pattern coordinates [0, 1]\nvarying mediump vec2 v_patternSize;\n#endif\n\n#if defined(PATTERN) || defined(SDF)\nvarying highp float v_accumulatedDistance; // we need to accumulated distance only if it is a pattern or an SDF line\n#endif\n\n#if defined(SDF) && !defined(HIGHLIGHT) // When we render the highlight, we want to treat the line as if it was solid\nconst float widthFactor = 2.0;\n#else\nconst float widthFactor = 1.0;\n#endif\n\nconst float scale = 1.0 / 31.0;\n\nvoid main()\n{\n  float a_bitset = a_segmentDirection.w;\n\n  float isColorLocked = getBit(a_bitset, 0);\n  float lineHalfWidth = a_accumulatedDistanceAndHalfWidth.y * scale;\n\n  v_transparency = 1.0;\n  v_color = a_color;\n  v_normal = a_offsetAndNormal.zw * scale;\n\n#ifdef ID\n  v_id = a_id;\n#endif\n\n#ifdef VV_OPACITY\n  v_transparency = getVVOpacity(a_vv.z);\n#endif\n\n#ifdef VV_COLOR\n  v_color = getVVColor(a_vv.y, v_color, isColorLocked);\n#endif\n\n#ifdef VV_SIZE\n  lineHalfWidth = 0.5 * getVVSize(2.0 * lineHalfWidth, a_vv.x);\n#endif\n\n#ifdef PATTERN\n  v_tlbr = a_tlbr / u_mosaicSize.xyxy;\n  v_patternSize = vec2(a_tlbr.z - a_tlbr.x, a_tlbr.w - a_tlbr.y);\n#endif\n\n  // make sure to clip the vertices in case that the width of the line is 0 (or negative)\n  float z = 2.0 * step(lineHalfWidth, 0.0);\n\n  // add an antialiasing distance. We use 0.2 rather than 0.5 in order to match the SVG renderer\n  // also limit the total line width to 1.3 pixels. Below this value lines don't look good compared\n  // to the SVG renderer\n  v_lineHalfWidth = max(lineHalfWidth, 0.45) + 0.2 * u_antialiasing;\n\n\n#ifdef HIGHLIGHT\n  v_lineHalfWidth = max(v_lineHalfWidth, 2.0);\n#endif\n\n  // for now assume that a thin line is a line which is under 2 pixels (1 pixels on either sides\n  // of the centerline) in practice, a thin line is a line who's half width vary from 0.45px to\n  // the value of thinLineHalfWidth, as the value is claped in line 221 above\n  mediump float thinLineFactor = max(THIN_LINE_WIDTH_FACTOR * step(v_lineHalfWidth, THIN_LINE_HALF_WIDTH), 1.0);\n\n  // calculate the relative distance from the centerline to the edge of the line. Since offset is\n  // given in integers (for the sake of using less attribute memory, we need to scale it back to\n  // the original range of ~ [0, 1]) in a case of a thin line we move each vertex twice as far\n  mediump vec2 dist = thinLineFactor * widthFactor * v_lineHalfWidth * a_offsetAndNormal.xy * scale;\n\n#if defined(PATTERN) || defined(SDF)\n  v_accumulatedDistance = a_accumulatedDistanceAndHalfWidth.x + dot(scale * a_segmentDirection.xy, dist / u_zoomFactor);\n#endif\n\n  vec3 offset = u_displayViewMat3 * vec3(dist, 0.0);\n  vec3 v_pos = u_dvsMat3 * vec3(a_pos.xy, 1.0) + offset;\n  vec3 pos = vec3(v_pos.xy, z);\n\n  applyFilter(v_color, pos, a_visible);\n\n  gl_Position = vec4(pos, 1.0);\n}\n"},text:{"text.frag":"precision lowp float;\n\nuniform lowp sampler2D u_texture;\n\nvarying mediump vec4 v_color;\nvarying mediump float v_antialiasingWidth;\nvarying mediump float v_edgeDistanceOffset;\nvarying mediump vec2 v_tex;\nvarying lowp float v_transparency;\n\n#ifdef ID\nvarying highp vec4 v_id;\n#endif // ID\n\nvoid main()\n{\n  // read the distance from the SDF texture\n  lowp float dist = texture2D(u_texture, v_tex).a;\n\n  // the edge distance if a factor of the outline width\n  // We cap this to 0.25 to prevent this from becomming negative / running into the glyph boundaries\n  float glyphEdgeDistance = max(0.75 - v_edgeDistanceOffset, 0.25);\n\n  #ifdef HIGHLIGHT\n    glyphEdgeDistance /= 2.0;\n  #endif\n\n  // use a smooth-step in order to calculate the geometry of the shape given by the distance field\n  lowp float alpha = smoothstep(glyphEdgeDistance - v_antialiasingWidth, glyphEdgeDistance + v_antialiasingWidth, dist) * v_transparency;\n\n  gl_FragColor = alpha * v_color;\n\n#ifdef ID\n  if (gl_FragColor.a < 1.0 / 255.0) {\n    discard;\n  }\n  gl_FragColor = v_id;\n#endif // ID\n}\n","text.vert":"precision mediump float;\n\n#include <materials/constants.glsl>\n#include <materials/utils.glsl>\n#include <materials/vv.glsl>\n#include <materials/effects.glsl>\n\nattribute vec2 a_pos;          // 2 * 2 (2 x signed 16)\nattribute vec4 a_id;           // 4 (4 x unsigned byte)\nattribute vec4 a_color;        // 4 (4 x unsigned byte)\nattribute vec2 a_vertexOffset; // 2 * 2 // (2 x signed 16) offset from the anchor point of the string\nattribute vec4 a_texFontSize;  // 4 (4 x unsigned byte) texture coordinatesm and font size\nattribute vec4 a_aux;          // hold onto additional information such as a bitset on the last byte (a_aux.w)\nattribute float a_visible;     // a one byte controlling the visibility of the vertex (a separate visibility buffer)\n\n#ifdef VV\nattribute highp vec4 a_vv;\n#endif\n\nuniform vec2 u_mosaicSize;\nuniform float u_pixelRatio;\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3; // Premultiplies DisplayMat3 * ViewMat3 * ScreenMat3\n\nvarying mediump vec4 v_color;\nvarying mediump float v_antialiasingWidth;\nvarying mediump float v_edgeDistanceOffset;\nvarying mediump vec2 v_tex;        // texture coordinates used to sample the glyph atlas\nvarying lowp float v_transparency; // the calculated transparency to be applied by the fragment shader. \n\n#ifdef ID\nvarying highp vec4 v_id;\n#endif // ID\n\nvoid main()\n{\n  float a_bitset = a_aux.w;\n\n  float isColorLocked = getBit(a_bitset, 0);\n  float isHalo = getBit(a_pos.x, 0);   // The lsb of pos denotes whether a vertex is part of the halo or not\n  float fontSize = a_texFontSize.z;\n  vec3 pos = vec3(floor(a_pos * 0.5), 1.0);\n  vec3 offset = vec3(a_vertexOffset * OFFSET_PRECISION, 0.0);\n  float scale = 1.0;\n\n  v_transparency = 1.0;\n  v_color = a_color;\n  v_tex = a_texFontSize.xy / u_mosaicSize;\n\n#ifdef ID\n  v_id = a_id;\n#endif\n\n#ifdef VV_OPACITY\n  v_transparency = getVVOpacity(a_vv.z);\n#endif\n\n#ifdef VV_COLOR\n  // we don't want to override the halo color\n  v_color = isHalo * a_color + (1.0 - isHalo) * getVVColor(a_vv.y, a_color, isColorLocked);\n#endif\n\n#ifdef VV_SIZE\n  float f = getVVSize(a_texFontSize.z, a_vv.x);\n  scale = f / fontSize; \n  fontSize = f;\n  offset.xy *= scale; \n#endif\n  \n#ifdef VV_ROTATION\n  offset = getVVRotationMat3(a_vv.w) * offset;\n#endif\n\n  vec3 v_pos = u_dvsMat3 * pos + u_displayMat3 * offset;\n  float fontScale = fontSize / SDF_FONT_SIZE;\n\n  // if isHalo is zero (not a halo) v_edgeDistanceOffset will end up being zero as well.\n  v_edgeDistanceOffset = isHalo * OUTLINE_SCALE * a_texFontSize.w / fontScale / MAX_SDF_DISTANCE;\n  v_antialiasingWidth = 0.105 * SDF_FONT_SIZE / fontSize / u_pixelRatio;\n\n  applyFilter(v_color, v_pos, a_visible);\n  \n  gl_Position = vec4(v_pos, 1.0);\n}\n"},"utils.glsl":"\nfloat getBit(in float bitset, in int bitIndex) {\n  float offset = pow(2.0, float(bitIndex));\n\n  return mod(floor(bitset / offset), 2.0);\n}\n","vv.glsl":"#if defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE)\n  #define VV_SIZE\n#endif\n\n#if defined(VV_COLOR) || defined(VV_SIZE) || defined(VV_OPACITY) || defined(VV_ROTATION)\n  #define VV\n#endif\n\n#ifdef VV_COLOR\nuniform highp float u_vvColorValues[8];\nuniform vec4 u_vvColors[8];\n#endif // VV_COLOR\n\n#ifdef VV_SIZE_MIN_MAX_VALUE\nuniform highp vec4 u_vvSizeMinMaxValue;\n#endif // VV_SIZE_MIN_MAX_VALUE\n\n#ifdef VV_SIZE_SCALE_STOPS\nuniform highp float u_vvSizeScaleStopsValue;\n#endif // VV_SIZE_SCALE_STOPS\n\n#ifdef VV_SIZE_FIELD_STOPS\nuniform highp float u_vvSizeFieldStopsValues[6];\nuniform float u_vvSizeFieldStopsSizes[6];\n#endif // VV_SIZE_FIELD_STOPS\n\n#ifdef VV_SIZE_UNIT_VALUE\nuniform highp float u_vvSizeUnitValueWorldToPixelsRatio;\n#endif // VV_SIZE_UNIT_VALUE\n\n#ifdef VV_OPACITY\nuniform highp float u_vvOpacityValues[8];\nuniform float u_vvOpacities[8];\n#endif // VV_OPACITY\n\n#ifdef VV_ROTATION\nuniform lowp float u_vvRotationType;\n#endif // VV_ROTATION\n\nconst highp float nanValue = 1e-30;\n\nbool isNan(float val) {\n  return (val == nanValue);\n  //return !( val < 0.0 || 0.0 < val || val == 0.0 );\n}\n\n#ifdef VV_SIZE_MIN_MAX_VALUE\nfloat getVVMinMaxSize(float sizeValue, float fallback) {\n  if (isNan(sizeValue)) {\n    return fallback;\n  }\n\n  // we need to multiply by 8 in order to translate to tile coordinates\n  float interpolationRatio = (sizeValue  - u_vvSizeMinMaxValue.x) / (u_vvSizeMinMaxValue.y - u_vvSizeMinMaxValue.x);\n  interpolationRatio = clamp(interpolationRatio, 0.0, 1.0);\n  return u_vvSizeMinMaxValue.z + interpolationRatio * (u_vvSizeMinMaxValue.w - u_vvSizeMinMaxValue.z);\n}\n#endif // VV_SIZE_MIN_MAX_VALUE\n\n#ifdef VV_SIZE_FIELD_STOPS\nconst int VV_SIZE_N = 6;\nfloat getVVStopsSize(float sizeValue, float fallback) {\n  if (isNan(sizeValue)) {\n    return fallback;\n  }\n\n  if (sizeValue <= u_vvSizeFieldStopsValues[0]) {\n    return u_vvSizeFieldStopsSizes[0];\n  }\n\n  for (int i = 1; i < VV_SIZE_N; ++i) {\n    if (u_vvSizeFieldStopsValues[i] >= sizeValue) {\n      float f = (sizeValue - u_vvSizeFieldStopsValues[i-1]) / (u_vvSizeFieldStopsValues[i] - u_vvSizeFieldStopsValues[i-1]);\n      return mix(u_vvSizeFieldStopsSizes[i-1], u_vvSizeFieldStopsSizes[i], f);\n    }\n  }\n\n  return u_vvSizeFieldStopsSizes[VV_SIZE_N - 1];\n}\n#endif // VV_SIZE_FIELD_STOPS\n\n#ifdef VV_SIZE_UNIT_VALUE\nfloat getVVUnitValue(float sizeValue, float fallback) {\n  if (isNan(sizeValue)) {\n    return fallback;\n  }\n\n  return u_vvSizeUnitValueWorldToPixelsRatio * sizeValue;\n}\n#endif // VV_SIZE_UNIT_VALUE\n\n#ifdef VV_OPACITY\nconst int VV_OPACITY_N = 8;\nfloat getVVOpacity(float opacityValue) {\n  if (isNan(opacityValue)) {\n    return 1.0;\n  }\n\n  if (opacityValue <= u_vvOpacityValues[0]) {\n    return u_vvOpacities[0];\n  }\n\n  for (int i = 1; i < VV_OPACITY_N; ++i) {\n    if (u_vvOpacityValues[i] >= opacityValue) {\n      float f = (opacityValue - u_vvOpacityValues[i-1]) / (u_vvOpacityValues[i] - u_vvOpacityValues[i-1]);\n      return mix(u_vvOpacities[i-1], u_vvOpacities[i], f);\n    }\n  }\n\n  return u_vvOpacities[VV_OPACITY_N - 1];\n}\n#endif // VV_OPACITY\n\n#ifdef VV_ROTATION\nmat4 getVVRotation(float rotationValue) {\n  // YF TODO: if the symbol has rotation we need to combine the symbo's rotation with the VV one\n  if (isNan(rotationValue)) {\n    return mat4(1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1);\n  }\n\n  float rotation = rotationValue;\n  if (u_vvRotationType == 1.0) {\n    rotation = 90.0 - rotation;\n  }\n\n  float angle = C_DEG_TO_RAD * rotation;\n\n  float sinA = sin(angle);\n  float cosA = cos(angle);\n\n  return mat4(cosA, sinA, 0, 0,\n              -sinA,  cosA, 0, 0,\n              0,     0, 1, 0,\n              0,     0, 0, 1);\n}\n\nmat3 getVVRotationMat3(float rotationValue) {\n  // YF TODO: if the symbol has rotation we need to combine the symbo's rotation with the VV one\n  if (isNan(rotationValue)) {\n    return mat3(1, 0, 0,\n                0, 1, 0,\n                0, 0, 1);\n  }\n\n  float rotation = rotationValue;\n  if (u_vvRotationType == 1.0) {\n    rotation = 90.0 - rotation;\n  }\n\n  float angle = C_DEG_TO_RAD * -rotation;\n\n  float sinA = sin(angle);\n  float cosA = cos(angle);\n\n  return mat3(cosA, -sinA, 0,\n             sinA, cosA, 0,\n              0,    0,    1);\n}\n#endif // VV_ROTATION\n\n#ifdef VV_COLOR\nconst int VV_COLOR_N = 8;\n\nvec4 getVVColor(float colorValue, vec4 fallback, float isColorLocked) {\n  if (isNan(colorValue) || isColorLocked == 1.0) {\n    return fallback;\n  }\n\n  if (colorValue <= u_vvColorValues[0]) {\n    return u_vvColors[0];\n  }\n\n  for (int i = 1; i < VV_COLOR_N; ++i) {\n    if (u_vvColorValues[i] >= colorValue) {\n      float f = (colorValue - u_vvColorValues[i-1]) / (u_vvColorValues[i] - u_vvColorValues[i-1]);\n      return mix(u_vvColors[i-1], u_vvColors[i], f);\n    }\n  }\n\n  return u_vvColors[VV_COLOR_N - 1];\n}\n#endif // VV_COLOR\n\nfloat getVVSize(in float size, in float vvSize)  {\n\n#ifdef VV_SIZE_MIN_MAX_VALUE\n  return getVVMinMaxSize(vvSize, size);\n\n#elif defined(VV_SIZE_SCALE_STOPS)\n  return u_vvSizeScaleStopsValue;\n\n#elif defined(VV_SIZE_FIELD_STOPS)\n  return getVVStopsSize(vvSize, size);\n\n#elif defined(VV_SIZE_UNIT_VALUE)\n  return getVVUnitValue(vvSize, size);\n\n#else\n  return size;\n\n#endif\n}\n"},raster:{"solid.frag":"precision mediump float;\n\nvoid main(void) {\n  gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}\n","texture.frag":"precision mediump float;\n\n// Texture coordinates.\nvarying vec2 v_texcoord;\n\n// Texture sampler.\nuniform sampler2D u_texture;\n\n// Opacity.\nuniform float u_opacity;\n\nvoid main(void) {\n  vec4 color = texture2D(u_texture, v_texcoord);\n  color.a *= u_opacity;\n  gl_FragColor = vec4(color.rgb * color.a, color.a);\n}\n","transform.vert":"precision mediump float;\n\n// Vertex position. Assumed normalized in the [0, 1] range.\nattribute vec2 a_position;\n\n// Transform matrix.\nuniform mat4 u_transform;\n\n// Output texture coordinates, for interpolation.\nvarying vec2 v_texcoord;\n\nvoid main(void) {\n  gl_Position = u_transform * vec4((2.0 * a_position - 1.0), 0.0, 1.0);\n  v_texcoord = a_position;\n}\n"},stencil:{"stencil.frag":"void main() {\n  gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n}\n","stencil.vert":"attribute vec2 a_pos;\n\nvoid main() {\n  gl_Position = vec4(a_pos, 0.0, 1.0);\n}\n"},tileInfo:{"tileInfo.frag":"uniform mediump sampler2D u_texture;\nvarying mediump vec2 v_tex;\n\nvoid main(void) {\n  lowp vec4 color = texture2D(u_texture, v_tex);\n  gl_FragColor = 0.75 * color;\n}\n","tileInfo.vert":"attribute vec2 a_pos;\n\nuniform highp mat3 u_dvsMat3;\n\nuniform mediump float u_depth;\nuniform mediump float u_coord_ratio;\nuniform mediump vec2 u_delta; // in tile coordinates\nuniform mediump vec2 u_dimensions; // in tile coordinates\n\nvarying mediump vec2 v_tex;\n\nvoid main() {\n  mediump vec2 offset = u_coord_ratio * vec2(u_delta + a_pos * u_dimensions);\n  vec3 v_pos = u_dvsMat3 * vec3(offset, 1.0);\n  \n  gl_Position = vec4(v_pos.xy, 0.0, 1.0);\n\n  v_tex = a_pos;\n}\n"},util:{"encoding.glsl":"// Factors to convert rgba back to float\nconst vec4 rgba2float_factors = vec4(\n    255.0 / (256.0),\n    255.0 / (256.0 * 256.0),\n    255.0 / (256.0 * 256.0 * 256.0),\n    255.0 / (256.0 * 256.0 * 256.0 * 256.0)\n  );\n\nfloat rgba2float(vec4 rgba) {\n  // Convert components from 0->1 back to 0->255 and then\n  // add the components together with their corresponding\n  // fixed point factors, i.e. (256^1, 256^2, 256^3, 256^4)\n  return dot(rgba, rgba2float_factors);\n}\n"}}}.apply(null,n))||(e.exports=r)},2191:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(91),i(565),i(361),i(1648),i(1608),i(59),i(66)],void 0===(r=function(e,t,i,n,r,o,a,s,l){return function(){function e(e){this._patternMatrix=n.mat3f32.create(),this._color=r.vec4f32.create(),this._solidrendererInitialized=!1,this._rendererInitialized=!1,this._programOptions={id:!1,pattern:!1},this._programCache=e,this._color.set([1,0,0,1])}return e.prototype.dispose=function(){this._solidVertexArrayObject&&(this._solidVertexArrayObject.dispose(),this._solidVertexArrayObject=null),this._vertexArrayObject&&(this._vertexArrayObject.dispose(),this._vertexArrayObject=null)},e.prototype.renderSolidColor=function(e,t){this._solidrendererInitialized||this._initializeSolidRenderer(e),e.bindVAO(this._solidVertexArrayObject);var i=this._programOptions;i.id=!1,i.pattern=!1;var n=this._programCache.getProgram(0,0,i);e.bindProgram(n),n.setUniformMatrix4fv("u_transformMatrix",t.u_matrix),n.setUniform2fv("u_normalized_origin",t.u_normalized_origin),n.setUniform1f("u_coord_range",t.u_coord_range||4096),n.setUniform1f("u_depth",t.u_depth||0),n.setUniform4fv("u_color",t.u_color||this._color),e.drawArrays(5,0,4),e.bindVAO()},e.prototype.render=function(e,t,n,r,o,s,l,d,u){this._rendererInitialized||this._initialize(e);var f=s.getPaintValue("background-color",n),c=u*s.getPaintValue("background-opacity",n),h=s.getPaintValue("background-pattern",n),_=void 0!==h,p=f[3]*c,v=_||p<1;if((!v||0!==r)&&(v||1!==r)){var m=3===r,g=(m?1:0)<<1|(_?1:0),y=this._programOptions;y.id=m,y.pattern=_;var x=this._programCache.getProgram(0,g,y);if(e.bindVAO(this._vertexArrayObject),e.bindProgram(x),x.setUniform1f("u_coord_range",o.coordRange),x.setUniform1f("u_depth",s.z||0),x.setUniformMatrix4fv("u_transformMatrix",o.tileTransform.transform),x.setUniform2fv("u_normalized_origin",o.tileTransform.displayCoord),_){var b=l.getMosaicItemPosition(h,!0);if(!b)return;var w=512*Math.pow(2,Math.floor(n)-o.key.level)*d;i.mat3.identity(this._patternMatrix);var D=w/b.size[0],V=w/b.size[1];this._patternMatrix[0]=D,this._patternMatrix[4]=V,l.bind(e,9729,b.page,5),x.setUniformMatrix3fv("u_pattern_matrix",this._patternMatrix),x.setUniform1f("u_opacity",c),x.setUniform2f("u_pattern_tl",b.tl[0],b.tl[1]),x.setUniform2f("u_pattern_br",b.br[0],b.br[1]),x.setUniform1i("u_texture",5)}else this._color[0]=p*f[0],this._color[1]=p*f[1],this._color[2]=p*f[2],this._color[3]=p,x.setUniform4fv("u_color",this._color);if(m){var z=a.int32To4Bytes(t.layerID);x.setUniform4f("u_id",z[0],z[1],z[2],z[3])}e.drawArrays(5,0,4),e.bindVAO()}},e.prototype._initializeSolidRenderer=function(e){if(this._solidrendererInitialized)return!0;var t=new Int8Array([0,0,1,0,0,1,1,1]),i=s.createVertex(e,35044,t),n=new l(e,this._programCache.getProgramAttributes(0),{geometry:[{name:"a_pos",count:2,type:5120,offset:0,stride:2,normalized:!1,divisor:0}]},{geometry:i});return this._solidVertexArrayObject=n,this._solidrendererInitialized=!0,!0},e.prototype._initialize=function(e){if(this._rendererInitialized)return!0;var t=[];t.push(o.i1616to32(0,0)),t.push(o.i1616to32(1,0)),t.push(o.i1616to32(0,1)),t.push(o.i1616to32(1,1));var i=new Uint32Array(t),n=s.createVertex(e,35044,i),r=new l(e,{a_pos:0},{geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:4,normalized:!1,divisor:0}]},{geometry:n});return this._vertexArrayObject=r,this._rendererInitialized=!0,!0},e}()}.apply(null,n))||(e.exports=r)},2192:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(18),i(264),i(262),i(361),i(545),i(1608),i(66)],void 0===(r=function(e,t,i,n,r,o,a,s,l){return function(){function e(e){this._viewProjMat=n.mat4f32.create(),this._offsetVector=r.vec3f32.create(),this._color=o.vec4f32.create(),this._strokeColor=o.vec4f32.create(),this._initialized=!1,this._programOptions={id:!1},this._programCache=e}return e.prototype.dispose=function(){},e.prototype.render=function(e,t,n,r,o,l,d,u,f){if(0!==t.triangleElementCount){this._initialized||this._initialize(e);var c=d.hasDataDrivenRadius?1:d.getPaintValue("circle-radius",n),h=d.hasDataDrivenColor?[1,1,1,1]:d.getPaintValue("circle-color",n),_=d.hasDataDrivenOpacity?1:d.getPaintValue("circle-opacity",n),p=d.hasDataDrivenStrokeWidth?1:d.getPaintValue("circle-stroke-width",n),v=d.hasDataDrivenStrokeColor?[1,1,1,1]:d.getPaintValue("circle-stroke-color",n),m=d.hasDataDrivenStrokeOpacity?1:d.getPaintValue("circle-stroke-opacity",n),g=d.hasDataDrivenBlur?0:d.getPaintValue("circle-blur",n),y=_*h[3]*f;this._color[0]=y*h[0],this._color[1]=y*h[1],this._color[2]=y*h[2],this._color[3]=y,y=m*v[3]*f,this._strokeColor[0]=y*v[0],this._strokeColor[1]=y*v[1],this._strokeColor[2]=y*v[2],this._strokeColor[3]=y;var x=l.tileTransform.transform,b=d.getPaintValue("circle-translate",n);if(0!==b[0]||0!==b[1]){i.mat4.copy(this._viewProjMat,l.tileTransform.transform);var w=b[0],D=b[1],V=0,z=0,T=l.coordRange/512,S=(1<<l.key.level)/Math.pow(2,n)*T;if(1===d.getPaintValue("circle-translate-anchor",n)){var I=-a.C_DEG_TO_RAD*o,O=Math.sin(I),C=Math.cos(I);V=S*(w*C-D*O),z=S*(w*O+D*C)}else V=S*w,z=S*D;this._offsetVector[0]=V,this._offsetVector[1]=z,this._offsetVector[2]=0,i.mat4.translate(this._viewProjMat,this._viewProjMat,this._offsetVector),x=this._viewProjMat}var A=this._getCircleVAO(e,l);if(A){e.bindVAO(A);var M=3===r,P=M?1:0,R=this._programOptions;R.id=M;var F=this._programCache.getProgram(5,P,R);if(e.bindProgram(F),F.setUniformMatrix4fv("u_transformMatrix",x),F.setUniformMatrix4fv("u_extrudeMatrix",u),F.setUniform2fv("u_normalized_origin",l.tileTransform.displayCoord),F.setUniform1f("u_depth",d.z),F.setUniform1f("u_radius",c),F.setUniform4fv("u_color",this._color),F.setUniform1f("u_blur",g),F.setUniform1f("u_stroke_width",p),F.setUniform4fv("u_stroke_color",this._strokeColor),F.setUniform1f("u_antialiasingWidth",1.2),M){var E=s.int32To4Bytes(t.layerID);F.setUniform4f("u_id",E[0],E[1],E[2],E[3])}e.drawElements(4,t.triangleElementCount,5125,12*t.triangleElementStart),e.bindVAO()}}},e.prototype._initialize=function(e){return!!this._initialized||(this._vertexAttributes={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:16,normalized:!1,divisor:0},{name:"a_color",count:4,type:5121,offset:4,stride:16,normalized:!0,divisor:0},{name:"a_stroke_color",count:4,type:5121,offset:8,stride:16,normalized:!0,divisor:0},{name:"a_data",count:4,type:5121,offset:12,stride:16,normalized:!1,divisor:0}]},this._initialized=!0,!0)},e.prototype._getCircleVAO=function(e,t){if(t.circleVertexArrayObject)return t.circleVertexArrayObject;var i=t.circleVertexBuffer,n=t.circleIndexBuffer;return i&&n?(t.circleVertexArrayObject=new l(e,this._programCache.getProgramAttributes(5),this._vertexAttributes,{geometry:i},n),t.circleVertexArrayObject):null},e}()}.apply(null,n))||(e.exports=r)},2193:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(132)],void 0===(r=function(e,t,i){Object.defineProperty(t,"__esModule",{value:!0});var n=function(){return function(e,t,i,n){this.fadeSpeed=e,this.minfadeLevel=t,this.maxfadeLevel=i,this.fadeChange=n}}();t.FadeProperties=n;var r=function(){function e(e){void 0===e&&(e=300),this._levelSnapshots=[],this._duration=e}return e.prototype.recordLevel=function(e){var t=i(),n=this._levelSnapshots;0===n.length&&(n.push({level:e,now:0}),n.push({level:e,now:0})),2!==n.length&&n[0].level===e||n.push({level:e,now:t})},e.prototype.needsRedraw=function(){if(0===this._levelSnapshots.length)return!1;for(var e=this._duration,t=this._levelSnapshots,i=t.length,n=t[i-1],r=-1;i>r+1&&t[r+1].now+e<n.now;)r++;for(r<0&&(r=0);r<i;r++)if(t[r].level!==n.level)return!0;return!1},e.prototype.getFadeValues=function(e){void 0===e&&(e=!1);for(var t=this._duration,n=i(),r=this._levelSnapshots;r.length>3&&r[1].now+t<n;)r.shift();r[1].now+t<n&&(r[0].level=r[1].level);var o=r[0].level,a=r[r.length-1],s=a.level,l=Math.min(o,s),d=Math.max(o,s),u=(a.level-r[1].level)/((a.now-r[1].now)/t),f=(n-a.now)/t*u;return e?{fadeSpeed:0,minfadeLevel:l,maxfadeLevel:d,fadeChange:0}:{fadeSpeed:u,minfadeLevel:l,maxfadeLevel:d,fadeChange:f}},e}();t.FadeRecorder=r}.apply(null,n))||(e.exports=r)},2194:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(91),i(565),i(18),i(264),i(262),i(361),i(545),i(1608),i(66)],void 0===(r=function(e,t,i,n,r,o,a,s,l,d,u){return function(){function e(e){this._viewProjMat=o.mat4f32.create(),this._offsetVector=a.vec3f32.create(),this._patternMatrix=n.mat3f32.create(),this._color=s.vec4f32.create(),this._outlineColor=s.vec4f32.create(),this._initialized=!1,this._fillProgramOptions={id:!1,dd:!1,pattern:!1},this._outlineProgramOptions={id:!1,dd:!1},this._programCache=e}return e.prototype.dispose=function(){},e.prototype.render=function(e,t,i,n,o,a,s,u,f,c,h){if(0!==t.triangleElementCount){this._initialized||this._initialize(e);var _=void 0!==s.getPaintValue("fill-pattern",i),p=s.hasDataDrivenColor?[1,1,1,1]:s.getPaintValue("fill-color",i),v=s.hasDataDrivenOpacity?1:s.getPaintValue("fill-opacity",i),m=v*p[3]*h;this._color[0]=m*p[0],this._color[1]=m*p[1],this._color[2]=m*p[2],this._color[3]=m;var g,y=3===o;y&&(g=d.int32To4Bytes(t.layerID));var x=a.tileTransform.transform,b=a.coordRange/512,w=s.getPaintValue("fill-translate",i);if(0!==w[0]||0!==w[1]){r.mat4.copy(this._viewProjMat,a.tileTransform.transform);var D=w[0],V=w[1],z=0,T=0,S=(1<<a.key.level)/Math.pow(2,i)*b;if(1===s.getPaintValue("fill-translate-anchor",i)){var I=-l.C_DEG_TO_RAD*n,O=Math.sin(I),C=Math.cos(I);z=S*(D*C-V*O),T=S*(D*O+V*C)}else z=S*D,T=S*V;this._offsetVector[0]=z,this._offsetVector[1]=T,this._offsetVector[2]=0,r.mat4.translate(this._viewProjMat,this._viewProjMat,this._offsetVector),x=this._viewProjMat}if(this._drawFill(e,t,i,o,a,s,u,x,c,h,y,g),s.getPaintValue("fill-antialias",i)&&!_&&t.outlineElementCount>0&&(1===o||3===o)){var A=s.hasDataDrivenOutline;if(s.outlineUsesFillColor){if(1!==this._color[3])return;this._outlineColor[0]=this._color[0],this._outlineColor[1]=this._color[1],this._outlineColor[2]=this._color[2],this._outlineColor[3]=this._color[3]}else{var M=s.hasDataDrivenOutlineColor?[1,1,1,1]:s.getPaintValue("fill-outline-color",i),P=v*M[3]*h;this._outlineColor[0]=P*M[0],this._outlineColor[1]=P*M[1],this._outlineColor[2]=P*M[2],this._outlineColor[3]=P}var R=.75/c,F=this._getOutlineVAO(e,a,A);if(F){e.bindVAO(F);var E=(y?1:0)<<1|(A?1:0),k=this._outlineProgramOptions;k.id=y,k.dd=A;var U=this._programCache.getProgram(2,E,k);e.bindProgram(U),U.setUniformMatrix4fv("u_transformMatrix",x),U.setUniformMatrix4fv("u_extrudeMatrix",f),U.setUniform2fv("u_normalized_origin",a.tileTransform.displayCoord),U.setUniform1f("u_depth",s.z+1/65536),U.setUniform1f("u_outline_width",R),U.setUniform4fv("u_color",this._outlineColor),y&&U.setUniform4f("u_id",g[0],g[1],g[2],g[3]),e.drawElements(4,t.outlineElementCount,5125,12*t.outlineElementStart),e.bindVAO()}}}},e.prototype._initialize=function(e){return!!this._initialized||(this._fillVertexAttributes={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:4,normalized:!1,divisor:0}]},this._fillVertexAttributesDD={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:8,normalized:!1,divisor:0},{name:"a_color",count:4,type:5121,offset:4,stride:8,normalized:!0,divisor:0}]},this._outlineVertexAttributes={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:8,normalized:!1,divisor:0},{name:"a_offset",count:2,type:5120,offset:4,stride:8,normalized:!1,divisor:0},{name:"a_xnormal",count:2,type:5120,offset:6,stride:8,normalized:!1,divisor:0}]},this._outlineVertexAttributesDD={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:12,normalized:!1,divisor:0},{name:"a_offset",count:2,type:5120,offset:4,stride:12,normalized:!1,divisor:0},{name:"a_xnormal",count:2,type:5120,offset:6,stride:12,normalized:!1,divisor:0},{name:"a_color",count:4,type:5121,offset:8,stride:12,normalized:!0,divisor:0}]},this._initialized=!0,!0)},e.prototype._drawFill=function(e,t,n,r,o,a,s,l,d,u,f,c){var h=a.getPaintValue("fill-pattern",n),_=void 0!==h,p=a.hasDataDrivenOpacity?1:u*a.getPaintValue("fill-opacity",n),v=a.hasDataDrivenColor?[1,1,1,1]:a.getPaintValue("fill-color",n),m=p*v[3]*u;this._color[0]=m*v[0],this._color[1]=m*v[1],this._color[2]=m*v[2],this._color[3]=m;var g=a.hasDataDrivenFill,y=_||m<1||g;if((!y||0!==r)&&(y||1!==r)){var x=this._getFillVAO(e,o,g);if(x){e.bindVAO(x);var b=(f?1:0)<<2|(g?1:0)<<1|(_?1:0),w=this._fillProgramOptions;w.id=f,w.dd=g,w.pattern=_;var D=this._programCache.getProgram(1,b,w);if(e.bindProgram(D),_){var V=s.getMosaicItemPosition(h,!0);if(!V)return e.bindVAO(),void e.bindProgram();var z=o.coordRange/512/Math.pow(2,Math.round(n)-o.key.level)/d;i.mat3.identity(this._patternMatrix);var T=1/(V.size[0]*z),S=1/(V.size[1]*z);this._patternMatrix[0]=T,this._patternMatrix[4]=S,s.bind(e,9729,V.page,5),D.setUniformMatrix3fv("u_pattern_matrix",this._patternMatrix),D.setUniform2f("u_pattern_tl",V.tl[0],V.tl[1]),D.setUniform2f("u_pattern_br",V.br[0],V.br[1]),D.setUniform1i("u_texture",5)}D.setUniformMatrix4fv("u_transformMatrix",l),D.setUniform2fv("u_normalized_origin",o.tileTransform.displayCoord),D.setUniform1f("u_depth",a.z+1/65536),D.setUniform4fv("u_color",this._color),f&&D.setUniform4f("u_id",c[0],c[1],c[2],c[3]),e.drawElements(4,t.triangleElementCount,5125,12*t.triangleElementStart),e.bindVAO()}}},e.prototype._getFillVAO=function(e,t,i){if(i){if(t.fillDDVertexArrayObject)return t.fillDDVertexArrayObject;var n=t.fillDDVertexBuffer,r=t.fillIndexBuffer;return n&&r?(t.fillDDVertexArrayObject=new u(e,this._programCache.getProgramAttributes(1),this._fillVertexAttributesDD,{geometry:n},r),t.fillDDVertexArrayObject):null}if(t.fillVertexArrayObject)return t.fillVertexArrayObject;n=t.fillVertexBuffer,r=t.fillIndexBuffer;return n&&r?(t.fillVertexArrayObject=new u(e,this._programCache.getProgramAttributes(1),this._fillVertexAttributes,{geometry:n},r),t.fillVertexArrayObject):null},e.prototype._getOutlineVAO=function(e,t,i){if(i){if(t.outlineDDVertexArrayObject)return t.outlineDDVertexArrayObject;var n=t.outlineDDVertexBuffer,r=t.outlineIndexBuffer;return n&&r?(t.outlineDDVertexArrayObject=new u(e,this._programCache.getProgramAttributes(2),this._outlineVertexAttributesDD,{geometry:n},r),t.outlineDDVertexArrayObject):null}if(t.outlineVertexArrayObject)return t.outlineVertexArrayObject;n=t.outlineVertexBuffer,r=t.outlineIndexBuffer;return n&&r?(t.outlineVertexArrayObject=new u(e,this._programCache.getProgramAttributes(2),this._outlineVertexAttributes,{geometry:n},r),t.outlineVertexArrayObject):null},e}()}.apply(null,n))||(e.exports=r)},2195:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(18),i(264),i(212),i(262),i(361),i(545),i(1608),i(66)],void 0===(r=function(e,t,i,n,r,o,a,s,l,d){return function(){function e(e){this._initialized=!1,this._viewProjMat=n.mat4f32.create(),this._offsetVector=o.vec3f32.create(),this._color=a.vec4f32.create(),this._dashArray=r.vec2f32.create(),this._programOptions={id:!1,dd:!1,pattern:!1},this._programCache=e}return e.prototype.dispose=function(){},e.prototype.render=function(e,t,n,r,o,a,d,u,f,c,h){if(0!==t.triangleElementCount){this._initialized||this._initialize(e);var _=a.tileTransform.transform,p=a.coordRange/512,v=d.getPaintValue("line-translate",n);if(0!==v[0]||0!==v[1]){i.mat4.copy(this._viewProjMat,a.tileTransform.transform);var m=v[0],g=v[1],y=0,x=0,b=(1<<a.key.level)/Math.pow(2,n)*p,w=o.rotation;if(1===d.getPaintValue("line-translate-anchor",n)){var D=-s.C_DEG_TO_RAD*w,V=Math.sin(D),z=Math.cos(D);y=b*(m*z-g*V),x=b*(m*V+g*z)}else y=b*m,x=b*g;this._offsetVector[0]=y,this._offsetVector[1]=x,this._offsetVector[2]=0,i.mat4.translate(this._viewProjMat,this._viewProjMat,this._offsetVector),_=this._viewProjMat}var T=d.getPaintValue("line-pattern",n),S=void 0!==T,I=1/c,O=d.getPaintValue("line-blur",n),C=d.hasDataDrivenColor?[1,1,1,1]:d.getPaintValue("line-color",n),A=d.hasDataDrivenOpacity?1:d.getPaintValue("line-opacity",n),M=d.hasDataDrivenWidth?1:d.getPaintValue("line-width",n),P=A*C[3]*h;this._color[0]=P*C[0],this._color[1]=P*C[1],this._color[2]=P*C[2],this._color[3]=P;var R,F=d.hasDataDrivenLine,E=3===r;E&&(R=l.int32To4Bytes(t.layerID));var k=this._getLineVAO(e,a,F);if(k){e.bindVAO(k);var U=(E?1:0)<<2|(F?1:0)<<1|(S?1:0),L=this._programOptions;L.id=E,L.dd=F,L.pattern=S;var N=this._programCache.getProgram(3,U,L);if(e.bindProgram(N),N.setUniformMatrix4fv("u_transformMatrix",_),N.setUniformMatrix4fv("u_extrudeMatrix",f),N.setUniform2fv("u_normalized_origin",a.tileTransform.displayCoord),N.setUniform1f("u_depth",d.z),N.setUniform1f("u_blur",O),N.setUniform1f("u_antialiasing",I),N.setUniform4fv("u_color",this._color),N.setUniform1f("u_width",M),E&&N.setUniform4f("u_id",R[0],R[1],R[2],R[3]),S){var j=u.getMosaicItemPosition(T,!0);j&&(u.bind(e,9729,j.page,5),N.setUniform2f("u_pattern_tl",j.tl[0],j.br[1]),N.setUniform2f("u_pattern_br",j.br[0],j.tl[1]),N.setUniform2f("u_spriteSize",p*j.size[0],j.size[1]),N.setUniform1i("u_texture",5))}else{var B=d.getPaintValue("line-dasharray",n);B.length<2&&(B=[1,-1]);var H=p;this._dashArray[0]=H*B[0],this._dashArray[1]=H*B[1],N.setUniform2fv("u_dasharray",this._dashArray)}e.drawElements(4,t.triangleElementCount,5125,12*t.triangleElementStart),e.bindVAO()}}},e.prototype._initialize=function(e){return!!this._initialized||(this._vertexAttributes={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:12,normalized:!1,divisor:0},{name:"a_offsetAndNormal",count:4,type:5120,offset:4,stride:12,normalized:!1,divisor:0},{name:"a_accumulatedDistance",count:2,type:5123,offset:8,stride:12,normalized:!1,divisor:0}]},this._vertexAttributesDD={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:20,normalized:!1,divisor:0},{name:"a_offsetAndNormal",count:4,type:5120,offset:4,stride:20,normalized:!1,divisor:0},{name:"a_accumulatedDistance",count:2,type:5122,offset:8,stride:20,normalized:!1,divisor:0},{name:"a_color",count:4,type:5121,offset:12,stride:20,normalized:!0,divisor:0},{name:"a_width",count:1,type:5126,offset:16,stride:20,normalized:!1,divisor:0}]},this._initialized=!0,!0)},e.prototype._getLineVAO=function(e,t,i){if(i){if(t.lineDDVertexArrayObject)return t.lineDDVertexArrayObject;var n=t.lineDDVertexBuffer,r=t.lineIndexBuffer;return n&&r?(t.lineDDVertexArrayObject=new d(e,this._programCache.getProgramAttributes(3),this._vertexAttributesDD,{geometry:n},r),t.lineDDVertexArrayObject):null}if(t.lineVertexArrayObject)return t.lineVertexArrayObject;n=t.lineVertexBuffer,r=t.lineIndexBuffer;return n&&r?(t.lineVertexArrayObject=new d(e,this._programCache.getProgramAttributes(3),this._vertexAttributes,{geometry:n},r),t.lineVertexArrayObject):null},e}()}.apply(null,n))||(e.exports=r)},2196:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(2197),i(2198)],void 0===(r=function(e,t,i,n){return function(){function e(e){this._iconRenderer=new i(e),this._sdfRenderer=new n(e)}return e.prototype.dispose=function(){this._iconRenderer&&(this._iconRenderer.dispose(),this._iconRenderer=null),this._sdfRenderer&&(this._sdfRenderer.dispose(),this._sdfRenderer=null)},e.prototype.render=function(e,t,i,n,r,o,a,s,l,d,u,f,c,h){t.hasData()&&(t.markerPerPageElementsMap.size>0&&this._iconRenderer.render(e,t,i,n,r,o,a,s,l,u,f,h),t.glyphPerPageElementsMap.size>0&&this._sdfRenderer.render(e,t,i,n,r,o,a,s,d,u,f,c,h))},e}()}.apply(null,n))||(e.exports=r)},2197:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(18),i(264),i(212),i(262),i(361),i(545),i(1608),i(66)],void 0===(r=function(e,t,i,n,r,o,a,s,l,d){return function(){function e(e){this._viewProjMat=n.mat4f32.create(),this._offsetVector=o.vec3f32.create(),this._spritesTextureSize=r.vec2f32.create(),this._color=a.vec4f32.create(),this._initialized=!1,this._programOptions={id:!1,dd:!1,sdf:!1},this._programCache=e}return e.prototype.dispose=function(){},e.prototype.render=function(e,t,n,r,o,a,d,u,f,c,h,_){var p=this;this._initialized||this._initialize(e);var v=u.hasDataDrivenIconSize?1:u.getLayoutValue("icon-size",n),m=u.hasDataDrivenIconColor?[1,1,1,1]:u.getPaintValue("icon-color",n),g=u.hasDataDrivenIconOpacity?1:u.getPaintValue("icon-opacity",n),y=m[3]*g*_;this._color[0]=y*m[0],this._color[1]=y*m[1],this._color[2]=y*m[2],this._color[3]=y;var x=u.getLayoutValue("icon-rotation-alignment",n);2===x&&(x=1===u.getLayoutValue("symbol-placement",n)?0:1);var b=0===x,w=t.isSDF,D=u.hasDataDrivenIcon,V=3===r,z=s.degToByte(o),T=d.tileTransform.transform,S=u.getPaintValue("icon-translate",n);if(0!==S[0]||0!==S[1]){i.mat4.copy(this._viewProjMat,d.tileTransform.transform);var I=S[0],O=S[1],C=0,A=0,M=d.coordRange/512,P=(1<<d.key.level)/Math.pow(2,n)*M;if(1===u.getPaintValue("icon-translate-anchor",n)){var R=-s.C_DEG_TO_RAD*o,F=Math.sin(R),E=Math.cos(R);C=P*(I*E-O*F),A=P*(I*F+O*E)}else C=P*I,A=P*O;this._offsetVector[0]=C,this._offsetVector[1]=A,this._offsetVector[2]=0,i.mat4.translate(this._viewProjMat,this._viewProjMat,this._offsetVector),T=this._viewProjMat}var k=b?c:h,U=this._getIconVAO(e,d,D);if(U){e.bindVAO(U);var L=(V?1:0)<<2|(D?1:0)<<1|(w?1:0),N=this._programOptions;N.id=V,N.dd=D,N.sdf=w;var j=this._programCache.getProgram(4,L,N);if(e.bindProgram(j),w){var B=u.getPaintValue("icon-halo-color",n),H=u.getPaintValue("icon-halo-width",n);j.setUniform4f("u_outlineColor",B[0],B[1],B[2],B[3]),j.setUniform1f("u_outlineSize",H)}if(j.setUniformMatrix4fv("u_transformMatrix",T),j.setUniformMatrix4fv("u_extrudeMatrix",k),j.setUniform2fv("u_normalized_origin",d.tileTransform.displayCoord),j.setUniform1f("u_depth",u.z),j.setUniform1f("u_mapRotation",z),j.setUniform1f("u_keepUpright",0),j.setUniform1f("u_level",10*n),j.setUniform1f("u_fadeSpeed",10*a.fadeSpeed),j.setUniform1f("u_minfadeLevel",10*a.minfadeLevel),j.setUniform1f("u_maxfadeLevel",10*a.maxfadeLevel),j.setUniform1f("u_fadeChange",10*(n+a.fadeChange)),j.setUniform1i("u_texture",5),j.setUniform1f("u_size",v),j.setUniform4fv("u_color",this._color),V){var W=l.int32To4Bytes(t.layerID);j.setUniform4f("u_id",W[0],W[1],W[2],W[3])}t.markerPerPageElementsMap.forEach(function(t,i){p._spritesTextureSize[0]=f.getWidth(i)/4,p._spritesTextureSize[1]=f.getHeight(i)/4,j.setUniform2fv("u_mosaicSize",p._spritesTextureSize),f.bind(e,9729,i,5),e.drawElements(4,t[1],5125,12*t[0])}),e.bindVAO()}},e.prototype._initialize=function(e){return!!this._initialized||(this._vertexAttributes={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:16,normalized:!1,divisor:0},{name:"a_vertexOffset",count:2,type:5122,offset:4,stride:16,normalized:!1,divisor:0},{name:"a_tex",count:4,type:5121,offset:8,stride:16,normalized:!1,divisor:0},{name:"a_levelInfo",count:4,type:5121,offset:12,stride:16,normalized:!1,divisor:0}]},this._vertexAttributesDD={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:24,normalized:!1,divisor:0},{name:"a_vertexOffset",count:2,type:5122,offset:4,stride:24,normalized:!1,divisor:0},{name:"a_tex",count:4,type:5121,offset:8,stride:24,normalized:!1,divisor:0},{name:"a_levelInfo",count:4,type:5121,offset:12,stride:24,normalized:!1,divisor:0},{name:"a_color",count:4,type:5121,offset:16,stride:24,normalized:!0,divisor:0},{name:"a_size",count:1,type:5126,offset:20,stride:24,normalized:!1,divisor:0}]},this._initialized=!0,!0)},e.prototype._getIconVAO=function(e,t,i){if(i){if(t.iconDDVertexArrayObject)return t.iconDDVertexArrayObject;var n=t.iconDDVertexBuffer,r=t.iconIndexBuffer;return n&&r?(t.iconDDVertexArrayObject=new d(e,this._programCache.getProgramAttributes(4),this._vertexAttributesDD,{geometry:n},r),t.iconDDVertexArrayObject):null}if(t.iconVertexArrayObject)return t.iconVertexArrayObject;n=t.iconVertexBuffer,r=t.iconIndexBuffer;return n&&r?(t.iconVertexArrayObject=new d(e,this._programCache.getProgramAttributes(4),this._vertexAttributes,{geometry:n},r),t.iconVertexArrayObject):null},e}()}.apply(null,n))||(e.exports=r)},2198:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(19),i(18),i(264),i(212),i(262),i(361),i(545),i(1608),i(66)],void 0===(r=function(e,t,i,n,r,o,a,s,l,d,u){return function(){function e(e){this._viewProjMat=r.mat4f32.create(),this._offsetVector=a.vec3f32.create(),this._extrudeMat=r.mat4f32.create(),this._scaleVec=a.vec3f32.create(),this._haloColor=s.vec4f32.create(),this._sdfColor=s.vec4f32.create(),this._initialized=!1,this._programOptions={id:!1,dd:!1},this._programCache=e}return e.prototype.dispose=function(){},e.prototype.render=function(e,t,r,a,s,u,f,c,h,_,p,v,m){var g=this;if(!i("esri-vector-tiles-avoid-text")){this._initialized||this._initialize(e);var y=l.degToByte(s),x=c.getLayoutValue("text-rotation-alignment",r);2===x&&(x=1===c.getLayoutValue("symbol-placement",r)?0:1);var b=0===x,w=c.getLayoutValue("text-keep-upright",r)&&b,D=3===a,V=.8*3/v,z=c.hasDataDrivenTextSize?1:c.getLayoutValue("text-size",r),T=c.hasDataDrivenTextColor?[1,1,1,1]:c.getPaintValue("text-color",r),S=c.hasDataDrivenTextOpacity?1:c.getPaintValue("text-opacity",r),I=T[3]*S*m;this._sdfColor[0]=I*T[0],this._sdfColor[1]=I*T[1],this._sdfColor[2]=I*T[2],this._sdfColor[3]=I,this._glyphTextureSize||(this._glyphTextureSize=o.vec2f32.fromValues(h.width/4,h.height/4));var O=f.tileTransform.transform,C=c.getPaintValue("text-translate",r);if(0!==C[0]||0!==C[1]){n.mat4.copy(this._viewProjMat,f.tileTransform.transform);var A=C[0],M=C[1],P=0,R=0,F=f.coordRange/512,E=(1<<f.key.level)/Math.pow(2,r)*F;if(1===c.getPaintValue("text-translate-anchor",r)){var k=-l.C_DEG_TO_RAD*s,U=Math.sin(k),L=Math.cos(k);P=E*(A*L-M*U),R=E*(A*U+M*L)}else P=E*A,R=E*M;this._offsetVector[0]=P,this._offsetVector[1]=R,this._offsetVector[2]=0,n.mat4.translate(this._viewProjMat,this._viewProjMat,this._offsetVector),O=this._viewProjMat}b?n.mat4.copy(this._extrudeMat,_):n.mat4.copy(this._extrudeMat,p),this._scaleVec[0]=1/24,this._scaleVec[1]=1/24,this._scaleVec[2]=1,n.mat4.scale(this._extrudeMat,this._extrudeMat,this._scaleVec);var N=c.hasDataDrivenText,j=this._getSDFVAO(e,f,N);if(j){e.bindVAO(j);var B=(D?1:0)<<1|(N?1:0),H=this._programOptions;H.id=D,H.dd=N;var W=this._programCache.getProgram(6,B,H);if(e.bindProgram(W),W.setUniformMatrix4fv("u_transformMatrix",O),W.setUniformMatrix4fv("u_extrudeMatrix",this._extrudeMat),W.setUniform2fv("u_normalized_origin",f.tileTransform.displayCoord),W.setUniform1f("u_depth",c.z+1/65536),W.setUniform2fv("u_mosaicSize",this._glyphTextureSize),W.setUniform1f("u_mapRotation",y),W.setUniform1f("u_keepUpright",w?1:0),W.setUniform1f("u_level",10*r),W.setUniform1f("u_fadeSpeed",10*u.fadeSpeed),W.setUniform1f("u_minfadeLevel",10*u.minfadeLevel),W.setUniform1f("u_maxfadeLevel",10*u.maxfadeLevel),W.setUniform1f("u_fadeChange",10*(r+u.fadeChange)),W.setUniform1i("u_texture",6),W.setUniform1f("u_size",z),W.setUniform1f("u_antialiasingWidth",V),D){var G=d.int32To4Bytes(t.layerID);W.setUniform4f("u_id",G[0],G[1],G[2],G[3])}t.glyphPerPageElementsMap.forEach(function(t,i){g._renderGlyphRange(e,t,i,c,h,W,r,S*m,3)}),e.bindVAO()}}},e.prototype._renderGlyphRange=function(e,t,i,n,r,o,a,s,l){r.bind(e,9729,i,6);var d=n.getPaintValue("text-halo-color",a),u=n.getPaintValue("text-halo-width",a);if(d[3]>0&&u>0){var f=d[3]*s;this._haloColor[0]=f*d[0],this._haloColor[1]=f*d[1],this._haloColor[2]=f*d[2],this._haloColor[3]=f;var c=n.getPaintValue("text-halo-blur",a)*l,h=u*l;o.setUniform4fv("u_color",this._haloColor),o.setUniform1f("u_halo",1),o.setUniform1f("u_edgeDistance",h),o.setUniform1f("u_edgeBlur",c),e.drawElements(4,t[1],5125,12*t[0])}this._sdfColor[3]>0&&(o.setUniform4fv("u_color",this._sdfColor),o.setUniform1f("u_halo",0),o.setUniform1f("u_edgeDistance",0),o.setUniform1f("u_edgeBlur",0),e.drawElements(4,t[1],5125,12*t[0]))},e.prototype._initialize=function(e){return!!this._initialized||(this._vertexAttributes={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:16,normalized:!1,divisor:0},{name:"a_vertexOffset",count:2,type:5122,offset:4,stride:16,normalized:!1,divisor:0},{name:"a_tex",count:4,type:5121,offset:8,stride:16,normalized:!1,divisor:0},{name:"a_levelInfo",count:4,type:5121,offset:12,stride:16,normalized:!1,divisor:0}]},this._vertexAttributesDD={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:24,normalized:!1,divisor:0},{name:"a_vertexOffset",count:2,type:5122,offset:4,stride:24,normalized:!1,divisor:0},{name:"a_tex",count:4,type:5121,offset:8,stride:24,normalized:!1,divisor:0},{name:"a_levelInfo",count:4,type:5121,offset:12,stride:24,normalized:!1,divisor:0},{name:"a_color",count:4,type:5121,offset:16,stride:24,normalized:!0,divisor:0},{name:"a_size",count:1,type:5126,offset:20,stride:24,normalized:!1,divisor:0}]},this._initialized=!0,!0)},e.prototype._getSDFVAO=function(e,t,i){if(i){if(t.textDDVertexArrayObject)return t.textDDVertexArrayObject;var n=t.textDDVertexBuffer,r=t.textIndexBuffer;return n&&r?(t.textDDVertexArrayObject=new u(e,this._programCache.getProgramAttributes(6),this._vertexAttributesDD,{geometry:n},r),t.textDDVertexArrayObject):null}if(t.textVertexArrayObject)return t.textVertexArrayObject;n=t.textVertexBuffer,r=t.textIndexBuffer;return n&&r?(t.textVertexArrayObject=new u(e,this._programCache.getProgramAttributes(6),this._vertexAttributes,{geometry:n},r),t.textVertexArrayObject):null},e}()}.apply(null,n))||(e.exports=r)},2199:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(361),i(545),i(59),i(53),i(66)],void 0===(r=function(e,t,i,n,r,o,a){return function(){function e(e){this._initialized=!1,this._color=i.vec4f32.fromValues(1,0,0,1),this._maxWidth=0,this._programOptions={id:!1,pattern:!1},this._programCache=e}return e.prototype.dispose=function(){this._outlineVertexArrayObject&&(this._outlineVertexArrayObject.dispose(),this._outlineVertexArrayObject=null),this._tileInfoVertexArrayObject&&(this._tileInfoVertexArrayObject.dispose(),this._tileInfoVertexArrayObject=null)},e.prototype.render=function(e,t){this._initialized||this._initialize(e);var i=this._programCache.getProgram(0,0,this._programOptions);if(i){e.bindVAO(this._outlineVertexArrayObject),e.bindProgram(i),i.setUniformMatrix4fv("u_transformMatrix",t.tileTransform.transform),i.setUniform2fv("u_normalized_origin",t.tileTransform.displayCoord),i.setUniform1f("u_coord_range",t.coordRange),i.setUniform1f("u_depth",0),i.setUniform4fv("u_color",this._color),e.drawArrays(3,0,4),e.bindVAO();var n=this._getTexture(e,t);if(n){var r=this._programCache.getProgram(7,0,null);r&&(e.bindVAO(this._tileInfoVertexArrayObject),e.bindProgram(r),e.bindTexture(n,0),r.setUniformMatrix4fv("u_transformMatrix",t.tileTransform.transform),r.setUniform2fv("u_normalized_origin",t.tileTransform.displayCoord),r.setUniform1f("u_depth",0),r.setUniform1f("u_coord_ratio",t.coordRange/512),r.setUniform2f("u_delta",8,8),r.setUniform2f("u_dimensions",n.descriptor.width,n.descriptor.height),e.drawArrays(5,0,4),e.bindVAO())}}},e.prototype._initialize=function(e){if(this._initialized)return!0;var t={geometry:[{name:"a_pos",count:2,type:5120,offset:0,stride:2,normalized:!1,divisor:0}]},i=new Int8Array([0,0,1,0,1,1,0,1]),n=r.createVertex(e,35044,i),o=new a(e,this._programCache.getProgramAttributes(0),t,{geometry:n}),s=new Int8Array([0,0,1,0,0,1,1,1]),l=r.createVertex(e,35044,s),d=new a(e,this._programCache.getProgramAttributes(7),t,{geometry:l});return this._outlineVertexArrayObject=o,this._tileInfoVertexArrayObject=d,this._initialized=!0,!0},e.prototype._getTexture=function(e,t){if(t.texture)return t.texture;this._canvas||(this._canvas=document.createElement("canvas"),this._canvas.setAttribute("id","canvas2d"),this._canvas.setAttribute("width","256"),this._canvas.setAttribute("height","32"),this._canvas.setAttribute("style","display:none"));var i=t.key.id,r=this._canvas.getContext("2d");r.font="24px sans-serif",r.textAlign="left",r.textBaseline="middle";var a=r.measureText(i),s=Math.pow(2,Math.ceil(n.log2(a.width+2)));return s>this._maxWidth&&(this._maxWidth=s),r.clearRect(0,0,this._maxWidth,32),r.fillStyle="blue",r.fillStyle="red",r.fillText(i,0,16),t.texture=new o(e,{target:3553,pixelFormat:6408,dataType:5121,samplingMode:9728},this._canvas),t.texture},e}()}.apply(null,n))||(e.exports=r)},2200:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(2201),i(55)],void 0===(r=function(e,t,i,n){Object.defineProperty(t,"__esModule",{value:!0});var r=function(){function e(){this._cache=new Array(8);for(var e=0;e<8;e++)this._cache[e]={}}return e.prototype.dispose=function(){this._programRepo&&(this._programRepo.dispose(),this._programRepo=null)},e.prototype.getProgram=function(e,t,i){var n=this._cache[e];if(!n[t]){var r=this._programRepo.getProgram(this._getProgramTemplate(e),i);n[t]=r}return n[t]},e.prototype.getProgramAttributes=function(e){switch(e){case 0:return i.background.attributes;case 5:return i.circle.attributes;case 1:return i.fill.attributes;case 4:return i.icon.attributes;case 3:return i.line.attributes;case 2:return i.outline.attributes;case 6:return i.text.attributes;case 7:return i.tileInfo.attributes}},e.prototype.initialize=function(e){this._programRepo||(this._programRepo=new n.ProgramCache(e))},e.prototype._getProgramTemplate=function(e){switch(e){case 0:return i.background;case 5:return i.circle;case 1:return i.fill;case 4:return i.icon;case 3:return i.line;case 2:return i.outline;case 6:return i.text;case 7:return i.tileInfo}},e}();t.default=r}.apply(null,n))||(e.exports=r)},2201:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(2202),i(55)],void 0===(r=function(e,t,i,n){Object.defineProperty(t,"__esModule",{value:!0});var r=function(e){return n.glslifyDefineMap({ID:e.id,PATTERN:e.pattern})};t.background={name:"background",shaders:function(e){return{vertexShader:r(e)+i.resolveIncludes("background/background.vert"),fragmentShader:r(e)+i.resolveIncludes("background/background.frag")}},attributes:{a_pos:0}};var o=function(e){return n.glslifyDefineMap({ID:e.id})};t.circle={name:"circle",shaders:function(e){return{vertexShader:o(e)+i.resolveIncludes("circle/circle.vert"),fragmentShader:o(e)+i.resolveIncludes("circle/circle.frag")}},attributes:{a_pos:0,a_color:1,a_stroke_color:2,a_data:3}};var a=function(e){return n.glslifyDefineMap({ID:e.id,DD:e.dd,PATTERN:e.pattern})};t.fill={name:"fill",shaders:function(e){return{vertexShader:a(e)+i.resolveIncludes("fill/fill.vert"),fragmentShader:a(e)+i.resolveIncludes("fill/fill.frag")}},attributes:{a_pos:0,a_color:1}};var s=function(e){return n.glslifyDefineMap({ID:e.id,DD:e.dd})};t.outline={name:"outline",shaders:function(e){return{vertexShader:s(e)+i.resolveIncludes("outline/outline.vert"),fragmentShader:s(e)+i.resolveIncludes("outline/outline.frag")}},attributes:{a_pos:0,a_offset:1,a_xnormal:2,a_color:3}};var l=function(e){return n.glslifyDefineMap({ID:e.id,DD:e.dd,SDF:e.sdf})};t.icon={name:"icon",shaders:function(e){return{vertexShader:l(e)+i.resolveIncludes("icon/icon.vert"),fragmentShader:l(e)+i.resolveIncludes("icon/icon.frag")}},attributes:{a_pos:0,a_vertexOffset:1,a_tex:2,a_levelInfo:3,a_color:4,a_size:5}};var d=function(e){return n.glslifyDefineMap({ID:e.id,DD:e.dd,PATTERN:e.pattern})};t.line={name:"line",shaders:function(e){return{vertexShader:d(e)+i.resolveIncludes("line/line.vert"),fragmentShader:d(e)+i.resolveIncludes("line/line.frag")}},attributes:{a_pos:0,a_offsetAndNormal:1,a_accumulatedDistance:2,a_color:3,a_width:4}};var u=function(e){return n.glslifyDefineMap({ID:e.id,DD:e.dd})};t.text={name:"text",shaders:function(e){return{vertexShader:u(e)+i.resolveIncludes("text/text.vert"),fragmentShader:u(e)+i.resolveIncludes("text/text.frag")}},attributes:{a_pos:0,a_vertexOffset:1,a_tex:2,a_levelInfo:3,a_color:4,a_size:5}},t.tileInfo={name:"tileInfo",shaders:{vertexShader:i.resolveIncludes("tileInfo/tileInfo.vert"),fragmentShader:i.resolveIncludes("tileInfo/tileInfo.frag")},attributes:{a_pos:0}}}.apply(null,n))||(e.exports=r)},2202:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(2203),i(585)],void 0===(r=function(e,t,i,n){Object.defineProperty(t,"__esModule",{value:!0});var r=new n(function(e){var t=i;return e.split("/").forEach(function(e){t&&(t=t[e])}),t});t.resolveIncludes=function(e){return r.resolveIncludes(e)}}.apply(null,n))||(e.exports=r)},2203:function(e,t,i){var n,r;n=[i.dj.c(e.i),t],void 0===(r=function(e,t){return{background:{"background.frag":"#ifdef PATTERN\nuniform lowp float u_opacity;\nuniform mediump vec2 u_pattern_tl;\nuniform mediump vec2 u_pattern_br;\nuniform sampler2D u_texture;\n\nvarying mediump vec2 v_tileTextureCoord;\n#else\nuniform lowp vec4 u_color;\n#endif // PATTERN\n\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif // ID\n\nvoid main() {\n#ifdef PATTERN\n  // normalize the calculated texture coordinate such that it fits in the range of 0 to 1.\n  mediump vec2 normalizedTextureCoord = mod(v_tileTextureCoord, 1.0);\n\n  // interpolate the image coordinate between the top-left and the bottom right to get the actual position to sample.\n  // after normalizing the position, we get a value ranging between 0 and 1 which refers to the entire texture, however\n  // we need to only sample from area that has our sprite in the mosaic.\n  mediump vec2 samplePos = mix(u_pattern_tl, u_pattern_br, normalizedTextureCoord);\n\n  // sample the sprite mosaic\n  lowp vec4 color = texture2D(u_texture, samplePos);\n  gl_FragColor = u_opacity * color;\n#else\n  gl_FragColor = u_color;\n#endif // PATTERN\n\n#ifdef ID\n  if (gl_FragColor.a < 1.0 / 255.0) {\n    discard;\n  }\n  gl_FragColor = v_id;\n#endif // ID\n}\n","background.vert":"precision mediump float;\n\nattribute vec2 a_pos;\n\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif // ID\n\nuniform highp mat4 u_transformMatrix;\nuniform mediump vec2 u_normalized_origin;\nuniform mediump float u_coord_range;\nuniform mediump float u_depth;\n\n#ifdef PATTERN\nuniform mediump mat3 u_pattern_matrix; // can we use medium precision?\nvarying mediump vec2 v_tileTextureCoord;\n#endif // PATTERN\n\nvoid main() {\n  gl_Position = vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(u_coord_range * a_pos, 0.0, 1.0);\n\n#ifdef PATTERN\n  // calculate the texture coordinates of the current vertex. It will of course get interpolated.\n  // The pattern matrix is a 3x3 scale matrix which 'tiles' the texture inside the tile, translating from tile coordinates\n  v_tileTextureCoord = (u_pattern_matrix * vec3(a_pos, 1.0)).xy;\n#endif // PATTERN\n\n#ifdef ID\n  v_id = u_id / 255.0;\n#endif // ID\n}\n"},circle:{"circle.frag":"precision lowp float;\n\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\n\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif // ID\n\nvoid main()\n{\n  mediump float dist = length(v_offset);\n\n  mediump float alpha = smoothstep(0.0, -v_blur, dist - 1.0);\n\n  lowp float color_mix_ratio = v_stroke_width < 0.01 ? 0.0 : smoothstep(-v_blur, 0.0, dist - v_radius / (v_radius + v_stroke_width));\n\n  gl_FragColor = alpha * mix(v_color, v_stroke_color, color_mix_ratio);\n\n#ifdef ID\n  if (gl_FragColor.a < 1.0 / 255.0) {\n    discard;\n  }\n  gl_FragColor = v_id;\n#endif // ID\n}\n","circle.vert":"precision mediump float;\n\nattribute vec2 a_pos;\nattribute vec4 a_color;\nattribute vec4 a_stroke_color;\nattribute vec4 a_data;\n\nconst float sizePrecision = 0.25; // 1/4\nconst float blurPrecision = 0.03125; // 1/32\n\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\n\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif // ID\n\n// the relative transformation of a vertex given in tile coordinates to a relative normalized coordinate\n// relative to the tile's upper left corner\n// the extrusion vector.\nuniform highp mat4 u_transformMatrix;\n\n// the extrude matrix which is responsible for the 'anti-zoom' as well as the rotation\nuniform highp mat4 u_extrudeMatrix;\n\n// u_normalized_origin is the tile's upper left corner given in normalized coordinates\nuniform highp vec2 u_normalized_origin;\n\n// the z of the layer. Given by the order of the layers in the style\nuniform mediump float u_depth;\n\n// the opacity of the layer given by the painter\nuniform mediump float u_radius;\nuniform lowp vec4 u_color;\nuniform mediump float u_blur;\nuniform mediump float u_stroke_width;\nuniform lowp vec4 u_stroke_color;\n\nuniform mediump float u_antialiasingWidth; // antialiasing (factors in the pixel_ratio for high res devices)\n\nvoid main()\n{\n  v_color = a_color * u_color;\n  v_stroke_color = a_stroke_color * u_stroke_color;\n  v_stroke_width = a_data[1] * sizePrecision * u_stroke_width;\n  v_radius = a_data[2] * u_radius;\n  v_blur = max(a_data[0] * blurPrecision + u_blur, u_antialiasingWidth / (v_radius + v_stroke_width));\n\n  mediump vec2 offset = vec2(mod(a_pos, 2.0) * 2.0 - 1.0);\n  v_offset = offset;\n\n#ifdef ID\n  v_id = u_id / 255.0;\n#endif // ID\n\n  gl_Position = vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(a_pos * 0.5, 0.0, 1.0) + u_extrudeMatrix * (v_radius + v_stroke_width) * vec4(offset, 0.0, 0.0);\n}\n"},fill:{"fill.frag":"precision lowp float;\n\n#ifdef PATTERN\nuniform mediump vec2 u_pattern_tl;\nuniform mediump vec2 u_pattern_br;\nuniform lowp sampler2D u_texture;\nvarying mediump vec2 v_tileTextureCoord;\n#endif // PATTERN\n\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif // ID\n\nvarying lowp vec4 v_color;\n\nvec4 mixColors(vec4 color1, vec4 color2) {\n  // perform un-premultiplied over operator (see https://en.wikipedia.org/wiki/Alpha_compositing#Alpha_blending)\n  // we use pre-multiplied colors hence the need for this kind of mixing. At lease we save ourselves an extra division...\n  float compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\n  vec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\n\n  return vec4(compositeColor, compositeAlpha);\n}\n\nvoid main()\n{\n#ifdef PATTERN\n  // normalize the calculated texture coordinate such that it fits in the range of 0 to 1.\n  mediump vec2 normalizedTextureCoord = mod(v_tileTextureCoord, 1.0);\n\n  // interpolate the image coordinate between the top-left and the bottom right to get the actual position to sample.\n  // after normalizing the position, we get a value ranging between 0 and 1 which refers to the entire texture, however\n  // we need to only sample from area that has our sprite in the mosaic.\n  mediump vec2 samplePos = mix(u_pattern_tl, u_pattern_br, normalizedTextureCoord);\n\n  // sample the sprite mosaic\n  lowp vec4 color = texture2D(u_texture, samplePos);\n  gl_FragColor = v_color[3] * color;\n#else\n  gl_FragColor = v_color;\n#endif // PATTERN\n\n#ifdef ID\n  if (gl_FragColor.a < 1.0 / 255.0) {\n    discard;\n  }\n  gl_FragColor = v_id;\n#endif // ID\n}\n","fill.vert":"precision mediump float;\n\nattribute vec2 a_pos;\n\nuniform highp mat4 u_transformMatrix;\nuniform highp vec2 u_normalized_origin;\nuniform mediump float u_depth;\n\n#ifdef PATTERN\nuniform mediump mat3 u_pattern_matrix;\nvarying mediump vec2 v_tileTextureCoord;\n#endif // PATTERN\n\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif // ID\n\n#ifdef DD\nattribute vec4 a_color;\n#endif // DD\nuniform lowp vec4 u_color;\nvarying lowp vec4 v_color;\n\nvoid main()\n{\n#ifdef DD\n  v_color = a_color * u_color;\n#else\n  v_color = u_color;\n#endif // DD\n\n#ifdef ID\n  v_id = u_id / 255.0;\n#endif // ID\n\n#ifdef PATTERN\n  // calculate the texture coordinates of the current vertex. It will of course get interpolated.\n  // The pattern matrix is a 3x3 scale matrix which 'tiles' the texture inside the tile, translating from tile coordinates\n  // (-4k to 8k -1) to texture coordinates.\n  v_tileTextureCoord = (u_pattern_matrix * vec3(a_pos, 1.0)).xy;\n#endif // PATTERN\n\n  gl_Position = vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(a_pos, 0, 1.0);\n}\n"},icon:{"icon.frag":"precision mediump float;\n\nuniform lowp sampler2D u_texture; // SDF texture\n#ifdef SDF\nuniform lowp vec4 u_color; // a color to override the one of the vertex\nuniform lowp vec4 u_outlineColor;\nuniform mediump float u_outlineSize;\n#endif // SDF\n\nvarying mediump vec2 v_tex;\n// the calculated transparency to be applied by the fragment shader. It is incorporating both the fade as well as the\n// opacity of the layer given by the painter\nvarying lowp float v_transparency;\n\nvarying mediump vec2 v_size;\n\nvarying lowp vec4 v_color;\n\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif // ID\n\n// we need the conversion function from RGBA to float\n#include <util/encoding.glsl>\n\nvec4 mixColors(vec4 color1, vec4 color2) {\n  // perform un-premultiplied over operator (see https://en.wikipedia.org/wiki/Alpha_compositing#Alpha_blending)\n  // we use pre-multiplied colors hence the need for this kind of mixing. At lease we save ourselves an extra division...\n  float compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\n  vec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\n\n  return vec4(compositeColor, compositeAlpha);\n}\n\nvoid main()\n{\n#ifdef SDF\n  lowp vec4 fillPixelColor = v_color;\n\n  // calculate the distance from the edge [-0.5, 0.5]\n  float d = rgba2float(texture2D(u_texture, v_tex)) - 0.5;\n\n  // the soft edge ratio is about 1.5 pixels allocated for the soft edge.\n  // 1 / 86 represents a single pixel given the size of the SDF is 128 and we add 4 pixels margins to deal with\n  // other non SDF types.\n  // The rasterized geometry takes only 86 pixels because of the extra 16 pixels margin for the outline.\n  const float sofetEdgeRatio = 0.248062016; // ==> (32.0 / 86.0) / 1.5;\n  float size = max(v_size.x, v_size.y);\n  float dist = d * sofetEdgeRatio * size;\n\n  // set the fragment's transparency according to the distance from the edge\n  fillPixelColor *= clamp(0.5 - dist, 0.0, 1.0);\n\n  // count for the outline\n  // therefore tint the entire icon area.\n  if (u_outlineSize > 0.25) {\n    lowp vec4 outlinePixelColor = u_outlineColor;\n    // the outline limit ratio is derived from the 16 pixels allocated for the outline and the fact that 1/86 represents\n    // a single pixel.\n    const float outlineLimitRatio = (16.0 / 86.0);\n    float clampedOutlineSize = sofetEdgeRatio * min(u_outlineSize, outlineLimitRatio * max(v_size.x, v_size.y));\n\n    outlinePixelColor *= clamp(0.5 - (abs(dist) - clampedOutlineSize), 0.0, 1.0);\n\n    // finally combine the outline and the fill colors\n    gl_FragColor = v_transparency * mixColors(fillPixelColor, outlinePixelColor);\n  }\n  else {\n    gl_FragColor = v_transparency * fillPixelColor;\n  }\n#else // not an SDF\n  lowp vec4 texColor = texture2D(u_texture, v_tex);\n  gl_FragColor = v_transparency * texColor;\n#endif // SDF\n\n#ifdef ID\n  if (gl_FragColor.a < 1.0 / 255.0) {\n    discard;\n  }\n  gl_FragColor = v_id;\n#endif // ID\n}\n","icon.vert":"attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_tex;\nattribute vec4 a_levelInfo;\n\n#ifdef DD\nattribute vec4 a_color;\nattribute mediump float a_size;\n#endif // DD\nuniform lowp vec4 u_color;\nuniform mediump float u_size;\n\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif // ID\n\nvarying lowp vec4 v_color;\n\n// the relative transformation of a vertex given in tile coordinates to a relative normalized coordinate\n// relative to the tile's upper left corner\n// the extrusion vector.\nuniform highp mat4 u_transformMatrix;\n\n// the extrude matrix which is responsible for the 'anti-zoom' as well as the rotation\nuniform highp mat4 u_extrudeMatrix;\n\n// u_normalized_origin is the tile's upper left corner given in normalized coordinates\nuniform highp vec2 u_normalized_origin;\n\n// the size of the mosaic given in pixels\nuniform vec2 u_mosaicSize;\n\n// the z of the layer. Given by the order of the layers in the style\nuniform mediump float u_depth;\n\n// the map's rotation from the north\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\n\n// indicate whether the current set of iconst should be kept upright when the map is rotated\nuniform lowp float u_keepUpright;\n\n// the rate of the change in the opacity (fade) of the icons\nuniform mediump float u_fadeSpeed;\n\n// the low level we transition (to/from)\nuniform mediump float u_minfadeLevel;\n\n// the high level we transition (to/from)\nuniform mediump float u_maxfadeLevel;\n\n// the amount of fade given teh current time past the last recorded level\nuniform mediump float u_fadeChange;\n\n// the opacity of the layer given by the painter\nuniform mediump float u_opacity;\n\n// the interpolated texture coordinate value to be used by the fragment shader in order to sample the sprite texture\nvarying mediump vec2 v_tex;\n\n// the calculated transparency to be applied by the fragment shader. It is incorporating both the fade as well as the\n// opacity of the layer given by the painter\nvarying lowp float v_transparency;\n\nvarying mediump vec2 v_size;\n\n// the vertex offsets are given in integers, therefore in order to maintain a reasonable precision we multiply the values\n// by 8 and then at the shader devide by the same number\nconst float C_OFFSET_PRECISION = 1.0 / 8.0;\n\nconst float C_256_TO_RAD = 3.14159265359 / 128.0;\nconst float C_DEG_TO_RAD = 3.14159265359 / 180.0;\nconst float tileCoordRatio = 1.0 / 8.0;\n\nvoid main()\n{\n  mediump float a_labelMinLevel = a_levelInfo[0];\n  mediump float a_angle         = a_levelInfo[1];\n  mediump float a_minLevel      = a_levelInfo[2];\n  mediump float a_maxLevel      = a_levelInfo[3];\n\n  // if the given vertex should not be visible simply clip it by adding it a value that will push it outside the clipping plane\n  mediump float delta_z = 0.0;\n\n  // If the label rotates with the map, and if the rotated label is upside down, hide it\n  mediump float rotated = mod(a_angle + u_mapRotation, 256.0);\n  delta_z += (1.0 - step(u_keepUpright, 0.0)) * step(64.0, rotated) * (1.0 - step(192.0, rotated)); //ie. z += (flip > 0) && (64 <= rotated) && (rotated < 192)\n\n  // u_level is the current service level adjusted for the change in font size\n  delta_z += 1.0 - step(a_minLevel, u_level); // Test if (level < minLevel)\n  delta_z += step(a_maxLevel, u_level); // Test if (maxLevel <= level)\n\n  // calculate the alpha given the change in the fade and the fade-speed\n  lowp float alpha = clamp((u_fadeChange - a_labelMinLevel) / u_fadeSpeed, 0.0, 1.0);\n\n  // if the speed is positive we are zooming in and therefore we need to 'fade-in'. Else we need to 'fade-out'\n  v_transparency = (u_fadeSpeed >= 0.0 ? alpha : 1.0 - alpha);\n\n  // now deal with the min/max fade-levels. If we exceeded the level we simply snap to 0 or 1\n  if (u_maxfadeLevel < a_labelMinLevel)\n  {\n    v_transparency = 0.0;\n  }\n  if (u_minfadeLevel >= a_labelMinLevel)\n  {\n    v_transparency = 1.0;\n  }\n\n  // if label had been faded out, clip it\n  delta_z += step(v_transparency, 0.0);\n\n  vec2 offset = C_OFFSET_PRECISION * a_vertexOffset;\n\n  v_size = abs(offset);\n\n#ifdef SDF\n  offset = (120.0 / 86.0) * offset;\n#endif // SDF\n\n#ifdef DD\n  mediump float icon_size = a_size * u_size;\n#else\n  mediump float icon_size = u_size;\n#endif // DD\n  gl_Position = vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(a_pos, 0.0, 1.0) + u_extrudeMatrix * icon_size * vec4(offset, delta_z, 0.0);\n\n#ifdef DD\n  v_color = a_color * u_color;\n#else\n  v_color = u_color;\n#endif // DD\n\n#ifdef ID\n  v_id = u_id / 255.0;\n#endif // ID\n\n  v_tex = a_tex.xy / u_mosaicSize;\n  v_transparency *= v_color.w;\n}\n"},line:{"line.frag":"varying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\n\nvarying mediump float v_lineHalfWidth;\nvarying lowp vec4 v_color;\n\nvarying mediump float v_blur;\n\n#ifdef PATTERN\nuniform mediump vec2 u_pattern_tl;\nuniform mediump vec2 u_pattern_br;\nuniform mediump vec2 u_spriteSize;\nuniform sampler2D u_texture;\n\n// Horizontal scale is used to scale the horizontal texture coordinate v_normal.x before adding it as an offset to the\n// accumulated distance. Most vertices will have v_normal.x == 0, because the pattern must be sampled only depending on\n// the v_accumulatedDistance value. But tessellation at caps can have vertices with v_normal.x != 0, thus allowing to\n// \"keep moving\" for a few more pixel even when the line has ended or has not started yet.\nconst mediump float tileCoordRatio = 8.0;\n#else\nvarying mediump vec2 v_dasharray;\n#endif\n\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif // ID\n\nvoid main()\n{\n  // dist represent the distance of the fragment from the line. 1.0 or -1.0 will be the values on the edge of the line,\n  // and any value in between will be inside the line (the sign represent the direction - right or left).\n  // since u_linewidth.s (half line width) is represented in pixels, dist is also given in pixels\n  mediump float fragDist = length(v_normal) * v_lineHalfWidth;\n\n  // calculate the alpha given the difference between the line-width and the distance of the fragment from the center-line.\n  // We need to count for both sides of the line.\n  lowp float alpha = clamp((v_lineHalfWidth - fragDist) / v_blur, 0.0, 1.0);\n\n#ifdef PATTERN\n  // we need to calculate the relative portion of the line texture along the line given the accumulated distance aliong the line\n  // The computed value should is anumber btween 0 and 1 which will later be used to interpolate btween the BR and TL values\n  mediump float relativeTexX = mod((v_accumulatedDistance + v_normal.x * v_lineHalfWidth * tileCoordRatio) / u_spriteSize.x, 1.0);\n\n  // in order to calculate the texture coordinates perpendicular to the line (Y axis), we use the interpolated normal values\n  // which range from -1.0 to 1.0. On the line's centerline, the value of the interpolated normal is 0.0, however the relative\n  // texture value should be 0.5 (given that at the bottom of the line, the texture coordinate must be equal to 0.0)\n  // (TL) ---------------------------      --\x3e left edge of line. Interpolated normal is 1.0\n  //              | -> line-width / 2\n  //      - - - - - - - - - - - - - -\n  //              | -> line-width / 2\n  //      ---------------------------- (BR)--\x3e right edge of line. Interpolated normal is -1.0\n\n  mediump float relativeTexY = 0.5 + (v_normal.y * v_lineHalfWidth / u_spriteSize.y);\n\n  // claculate the actual texture coordinates by interpolating between the TL/BR pattern coordinates\n  mediump vec2 texCoord = mix(u_pattern_tl, u_pattern_br, vec2(relativeTexX, relativeTexY));\n\n  // get the color from the texture\n  lowp vec4 color = texture2D(u_texture, texCoord);\n\n  // finally write the fragment value\n  gl_FragColor = alpha * v_color[3] * color;\n#else\n  // now calculate the dashes given the accumulated distance of the line:\n  // start with calculating a normalized position along the line\n  lowp float dashPos =  mod(v_accumulatedDistance, v_dasharray.x + v_dasharray.y);\n\n  // calculate the contribution to the alpha of the dash part. It is provided by the shortest portion of the position along the dash.\n  // we must clamp since the value might be bigger than 1 or smaller than zero (when over a dash).\n  //   | <--- pos along the dash part\n  // -------_______-------_______\n  // when the dashPos is over the 'gap' part of the dash dasharray.x - dashPos is negative and therefore the alpha will\n  // get clamped to zero.\n  // when dasharray.x - dashPos is positive, or when dashPos is smaller than 1.0, it gives us a soft edge to each dash part.\n  // along the direction of the line.\n  lowp float dashAlpha = clamp(min(dashPos, v_dasharray.x - dashPos) + 0.5, 0.0, 1.0);\n\n  // if we don't have a no-data part to the dash then it is a solid line\n  dashAlpha = max(sign(-v_dasharray.y), dashAlpha);\n  // finally multiply the fragment's alpha by the calculated dash-alpha\n  alpha *= dashAlpha;\n\n  // output the fragment color\n  gl_FragColor = alpha * v_color;\n#endif // PATTERN\n\n#ifdef ID\n  if (gl_FragColor.a < 1.0 / 255.0) {\n    discard;\n  }\n  gl_FragColor = v_id;\n#endif // ID\n}\n","line.vert":"/* The implementation of the renderer is based on the article and implementation of MB described here:\n* https://www.mapbox.com/blog/drawing-antialiased-lines/\n*/\n\nattribute vec2 a_pos;\nattribute vec4 a_offsetAndNormal;\nattribute vec2 a_accumulatedDistance;\n\n// the relative transformation of a vertex given in tile coordinates to a relative normalized coordinate\n// relative to the tile's upper left corner\n// the extrusion vector.\nuniform highp mat4 u_transformMatrix;\n\n// the extrude matrix which is responsible for the 'anti-zoom' as well as the rotation\nuniform highp mat4 u_extrudeMatrix;\n\n// u_normalized_origin is the tile's upper left corner given in normalized coordinates\nuniform highp vec2 u_normalized_origin;\n\nuniform mediump float u_blur;\nuniform mediump float u_antialiasing; // the feather distance at which the line edge fades out\n\n// the z of the layer. Given by the order of the layers in the style\nuniform mediump float u_depth;\n\n// the interpolated normal to the line. the information is packed into the two LSBs of the vertex coordinate\nvarying mediump vec2 v_normal;\n\n// the accumulated distance along the line. We need this information in order to render the dashes.\nvarying highp float v_accumulatedDistance;\n\nconst float scale = 1.0 / 31.0;\n\n#ifdef DD\nattribute vec4 a_color;\nattribute mediump float a_width;\n#endif // DD\nuniform lowp vec4 u_color;\nuniform mediump float u_width;\n\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif // ID\n\nvarying lowp vec4 v_color;\nvarying mediump float v_lineHalfWidth; // the inset and outset of the line\nvarying mediump float v_blur;\n\n#ifndef PATTERN\nuniform mediump vec2 u_dasharray;\nvarying mediump vec2 v_dasharray;\n#endif\n\nvoid main()\n{\n  v_normal = a_offsetAndNormal.zw * scale;\n\n#ifdef DD\n  v_lineHalfWidth = a_width * u_width;\n#else\n  v_lineHalfWidth = u_width;\n#endif // DD\n\n  v_lineHalfWidth += u_antialiasing;\n  v_lineHalfWidth *= 0.5;\n\n#ifndef PATTERN\n#ifdef DD\n  v_dasharray = u_dasharray * a_width;\n#else\n  v_dasharray = u_dasharray * u_width;\n#endif // DD\n#endif\n\n  // calculate the relative distance from the centerline to the edge of the line. Since offset is given in integers (for the\n  // sake of using less attribute memory, we need to scale it back to the original range of ~ 0: 1)\n  mediump vec2 dist = v_lineHalfWidth * a_offsetAndNormal.xy * scale;\n\n  // transform the vertex\n  gl_Position = vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(a_pos, 0.0, 1.0) + u_extrudeMatrix * vec4(dist, 0.0, 0.0);\n\n  // the accumulated distance will be used to calculate the dashes (or the no-data...)\n  v_accumulatedDistance = a_accumulatedDistance.x;\n\n  v_blur = u_blur + u_antialiasing;\n\n  #ifdef DD\n    v_color = a_color * u_color;\n  #else\n    v_color = u_color;\n  #endif // DD\n\n  #ifdef ID\n    v_id = u_id / 255.0;\n  #endif // ID\n}\n"},outline:{"outline.frag":"varying lowp vec4 v_color;\nvarying mediump vec2 v_normal;\n\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif // ID\n\nvoid main()\n{\n  // Calculate the distance of the pixel from the line in pixels.\n  lowp float dist = abs(v_normal.y);\n\n  lowp float alpha = smoothstep(1.0, 0.0, dist);\n  gl_FragColor = alpha * v_color;\n\n#ifdef ID\n  if (gl_FragColor.a < 1.0 / 255.0) {\n    discard;\n  }\n  gl_FragColor = v_id;\n#endif // ID\n}\n","outline.vert":"attribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec2 a_xnormal;\n\n#ifdef DD\nattribute vec4 a_color;\n#endif // DD\nuniform lowp vec4 u_color;\nvarying lowp vec4 v_color;\n\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif // ID\n\nuniform highp mat4 u_transformMatrix;\nuniform highp mat4 u_extrudeMatrix;\nuniform highp vec2 u_normalized_origin;\nuniform mediump float u_depth;\nuniform mediump float u_outline_width;\n\nvarying lowp vec2 v_normal;\n\nconst float scale = 1.0 / 15.0;\n\nvoid main()\n{\n#ifdef DD\n  v_color = a_color * u_color;\n#else\n  v_color = u_color;\n#endif // DD\n\n#ifdef ID\n  v_id = u_id / 255.0;\n#endif // ID\n\n  v_normal = a_xnormal;\n\n  // calculate the relative distance from the centerline to the edge of the line. Since offset is given in integers (for the\n  // sake of using less attribute memory, we need to scale it back to the original range of ~ 0: 1)\n  mediump vec4 dist = vec4(u_outline_width * a_offset * scale, 0.0, 0.0);\n\n  // Remove the texture normal bit of the position before scaling it with the\n  // model/view matrix. Add the extrusion vector *after* the model/view matrix\n  // because we're extruding the line in pixel space, regardless of the current\n  // tile's zoom level.\n  gl_Position = vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(a_pos, 0.0, 1.0) + u_extrudeMatrix * dist;\n}\n"},text:{"text.frag":"uniform lowp sampler2D u_texture;\nuniform mediump float u_edgeDistance;\n\nvarying lowp vec2 v_tex;\nvarying lowp float v_transparency;\nvarying lowp vec4 v_color;\nvarying mediump float v_edgeWidth;\nvarying mediump float v_edgeDistance;\n\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif // ID\n\n// this is taken from http://www.valvesoftware.com/publications/2007/SIGGRAPH2007_AlphaTestedMagnification.pdf\n// and https://www.mapbox.com/blog/text-signed-distance-fields/\n// http://metalbyexample.com/rendering-text-in-metal-with-signed-distance-fields/\n\nvoid main()\n{\n  // read the distance from the SDF texture\n  lowp float dist = texture2D(u_texture, v_tex).a;\n\n  // use a smooth-step in order to calculate the geometry of the shape given by the distance field\n  mediump float alpha = smoothstep(v_edgeDistance - v_edgeWidth, v_edgeDistance + v_edgeWidth, dist) * v_transparency;\n\n  gl_FragColor = alpha * v_color;\n\n#ifdef ID\n  if (gl_FragColor.a < 1.0 / 255.0) {\n    discard;\n  }\n  gl_FragColor = v_id;\n#endif // ID\n}\n","text.vert":"attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_tex;\nattribute vec4 a_levelInfo;\n\nuniform lowp vec4 u_color; // always defined as halo does not support data driven but text does\n#ifdef DD\nattribute vec4 a_color;\n#endif // DD\nvarying lowp vec4 v_color;\n\nuniform mediump float u_size;\n#ifdef DD\nattribute mediump float a_size;\n#endif // DD\nvarying mediump float v_size;\n\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif // ID\n\n\n// attribute bool a_visible; // --\x3e a one bit controlling the visibility of the vertex\n\n// the relative transformation of a vertex given in tile coordinates to a relative normalized coordinate\n// relative to the tile's upper left corner\n// the extrusion vector.\nuniform highp mat4 u_transformMatrix;\n\n// the extrude matrix which is responsible for the 'anti-zoom' as well as the rotation\nuniform highp mat4 u_extrudeMatrix;\n\n// u_normalized_origin is the tile's upper left corner given in normalized coordinates\nuniform highp vec2 u_normalized_origin;\n\n// the size of the mosaic given in pixels\nuniform vec2 u_mosaicSize;\n\n// the z of the layer. Given by the order of the layers in the style\nuniform mediump float u_depth;\n\n// the map's rotation from the north\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\n\n// indicate whether the current set of iconst should be kept upright when the map is rotated\nuniform lowp float u_keepUpright;\n\n// the rate of the change in the opacity (fade) of the icons\nuniform mediump float u_fadeSpeed;\n\n// the low level we transition (to/from)\nuniform mediump float u_minfadeLevel;\n\n// the high level we transition (to/from)\nuniform mediump float u_maxfadeLevel;\n\n// the amount of fade given teh current time past the last recorded level\nuniform mediump float u_fadeChange;\n\n// the opacity of the layer given by the painter\nuniform mediump float u_opacity;\n\n// the interpolated texture coordinate value to be used by the fragment shader in order to sample the sprite texture\nvarying lowp vec2 v_tex;\n\n// the calculated transparency to be applied by the fragment shader. It is incorporating both the fade as well as the\n// opacity of the layer given by the painter\nvarying lowp float v_transparency;\n\n// the vertex offsets are given in integers, therefore in order to maintain a reasonable precision we multiply the values\n// by 8 and then at the shader divide by the same number\nconst float offsetPrecision = 1.0 / 8.0;\n\n// outline position and appearance\nconst mediump float edgePos = 0.75; // defined by the SDF encoding\nuniform mediump float u_edgeDistance;\nuniform mediump float u_edgeBlur;\nuniform mediump float u_antialiasingWidth; // antialiasing (factors in the pixel_ratio for high res devices)\n\nvarying mediump float v_edgeDistance; // will factor in the size\nvarying mediump float v_edgeWidth; // will factor in the size\n\nuniform lowp float u_halo; // needed to avoid using the color attribute for halo\n\nvoid main()\n{\n  mediump float a_labelMinLevel = a_levelInfo[0];\n  mediump float a_angle        = a_levelInfo[1];\n  mediump float a_minLevel    = a_levelInfo[2];\n  mediump float a_maxLevel    = a_levelInfo[3];\n\n  // if the given vertex should not be visible simply clip it by adding it a value that will push it outside the clipping plane\n  mediump float delta_z = 0.0;\n\n  // TODO: force clipping the vertex in case that the vertex isn't visible\n  //delta_z += a_visible ? 0.0 : 1.0;\n\n  // If the label rotates with the map, and if the rotated label is upside down, hide it\n  mediump float rotated = mod(a_angle + u_mapRotation, 256.0);\n  delta_z += (1.0 - step(u_keepUpright, 0.0)) * step(64.0, rotated) * (1.0 - step(192.0, rotated)); //ie. z += (flip > 0) && (64 <= rotated) && (rotated < 192)\n\n  // u_level is the current service level adjusted for the change in font size\n  delta_z += 1.0 - step(a_minLevel, u_level); // Test if (level < minLevel)\n  delta_z += step(a_maxLevel, u_level); // Test if (maxLevel <= level)\n\n  // calculate the alpha given the change in the fade and the fade-speed\n  lowp float alpha = clamp((u_fadeChange - a_labelMinLevel) / u_fadeSpeed, 0.0, 1.0);\n\n  // if the speed is positive we are zooming in and therefore we need to 'fade-in'. Else we need to 'fade-out'\n  v_transparency = (u_fadeSpeed >= 0.0 ? alpha : 1.0 - alpha);\n\n  // now deal with the min/max fade-levels. If we exceeded the level we simply snap to 0 or 1\n  if (u_maxfadeLevel < a_labelMinLevel)\n  {\n    v_transparency = 0.0;\n  }\n  if (u_minfadeLevel >= a_labelMinLevel)\n  {\n    v_transparency = 1.0;\n  }\n\n  // if label has been faded out, clip it\n  delta_z += step(v_transparency, 0.0);\n\n  v_tex = a_tex.xy / u_mosaicSize;\n\n#ifdef DD\n  if (u_halo > 0.5)\n  {\n    v_color = u_color;\n  }\n  else\n  {\n    v_color = a_color * u_color;\n    // opacity already factored in a_color\n  }\n#else\n  v_color = u_color;\n#endif // DD\n\n#ifdef DD\n  v_size = a_size * u_size;\n#else\n  v_size = u_size;\n#endif // DD\n\n#ifdef ID\n  v_id = u_id / 255.0;\n#endif // ID\n\n  v_edgeDistance = edgePos - u_edgeDistance / v_size;\n  v_edgeWidth = (u_antialiasingWidth + u_edgeBlur) / v_size;\n\n  gl_Position = vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(a_pos, 0.0, 1.0) + u_extrudeMatrix * v_size * vec4(offsetPrecision * a_vertexOffset, delta_z, 0.0);\n}\n"},tileInfo:{"tileInfo.frag":"uniform mediump sampler2D u_texture;\nvarying mediump vec2 v_tex;\n\nvoid main(void) {\n  lowp vec4 color = texture2D(u_texture, v_tex);\n  gl_FragColor = 0.75 * color;\n}\n","tileInfo.vert":"attribute vec2 a_pos;\n\nuniform highp mat4 u_transformMatrix;\nuniform mediump vec2 u_normalized_origin;\nuniform mediump float u_depth;\nuniform mediump float u_coord_ratio;\nuniform mediump vec2 u_delta; // in tile coordinates\nuniform mediump vec2 u_dimensions; // in tile coordinates\n\nvarying mediump vec2 v_tex;\n\nvoid main() {\n  mediump vec2 offests = u_coord_ratio * vec2(u_delta + a_pos * u_dimensions);\n  gl_Position = vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(offests, 0.0, 1.0);\n\n  v_tex = a_pos;\n}\n"},util:{"encoding.glsl":"// Factors to convert rgba back to float\nconst vec4 rgba2float_factors = vec4(\n    255.0 / (256.0),\n    255.0 / (256.0 * 256.0),\n    255.0 / (256.0 * 256.0 * 256.0),\n    255.0 / (256.0 * 256.0 * 256.0 * 256.0)\n  );\n\nfloat rgba2float(vec4 rgba) {\n  // Convert components from 0->1 back to 0->255 and then\n  // add the components together with their corresponding\n  // fixed point factors, i.e. (256^1, 256^2, 256^3, 256^4)\n  return dot(rgba, rgba2float_factors);\n}\n"}}}.apply(null,n))||(e.exports=r)}}]);